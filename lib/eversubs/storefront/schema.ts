/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/v1/subscriptions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve Subscription
         * @description Retrieve subscriptions with flexible filtering and pagination.
         *
         *     Retrieve subscriptions for the authenticated customer. Only subscriptions belonging to the customer (derived from JWT) are returned.
         *
         *     ### Args
         *
         *     - `limit`: Maximum number of results to retrieve (1-1000, defaults to 50)
         *     - `cursor`: Pagination cursor from previous response's `next_cursor` field
         *     - `subscription_id`: Shopify subscription contract ID for direct retrieval:
         *         - Example: `"gid://shopify/SubscriptionContract/123"`
         *         - When provided, returns single subscription or empty list
         *     - `subscription_ids`: List of shopify subscription contract IDs for direct retrieval:
         *         - Example: `["gid://shopify/SubscriptionContract/123", "gid://shopify/SubscriptionContract/456"]`
         *         - When provided, returns list of subscriptions or empty list
         *     - `status`: Contract status filter with options:
         *         - `"ACTIVE"`: Currently active subscriptions
         *         - `"CANCELLED"`: Cancelled subscriptions
         *         - `"EXPIRED"`: Expired subscriptions
         *         - `"FAILED"`: Failed subscriptions
         *         - `"PAUSED"`: Temporarily paused subscriptions
         *         - `"STALE"`: Stale subscriptions
         *
         *
         *     ### Returns
         *
         *     **SubscriptionsResponse** containing:
         *
         *     - `subscriptions`: List of subscription contract details
         *     - `next_cursor`: Pagination cursor for retrieving next page (if more results available)
         *
         *     ### Raises
         *
         *     - **HTTPException (400)**: Invalid query filters
         *     - **HTTPException (500)**: Query execution fails
         *
         *     ### Notes
         *
         *     - Only returns subscriptions belonging to the authenticated customer
         *     - Direct subscription lookup validates ownership before returning
         *     - When no status filter is provided, returns subscriptions of all statuses
         *     - Pagination uses cursor-based approach for consistent results across pages
         */
        get: operations["retrieve_subscription_v1_subscriptions_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/subscriptions/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cancel Subscription
         * @description Cancel a subscription contract.
         *
         *     Customers can cancel their own subscriptions. The subscription must belong to the authenticated customer. Any one-time add-on products can be moved to another active subscription.
         *
         *     ### Args
         *
         *     - `subscription_id`: ID of the subscription to cancel (required)
         *     - `reason`: Reason for cancelling (required for audit)
         *     - `other_cancellation_reason`: Additional details about the cancellation reason (optional)
         *     - `move_one_times_to_next_eligible_date`: Whether to reassign one-time products to the next eligible date (default: True)
         *     - `permanent`: If True, permanently cancels in Shopify (status=CANCELLED, cannot reactivate).
         *       Default: False (status=PAUSED, can reactivate later)
         *     - `reason_id`: Optional cancellation reason ID from churn prevention flow. When provided, logs CHURN_PREVENTION/CANCELLATION_COMPLETED activity.
         *
         *     ### Returns
         *
         *     **SubscriptionResponse** containing:
         *
         *     - `subscription`: The cancelled subscription contract details
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         *     - **HTTPException (404)**: Contract not found
         *     - **HTTPException (500)**: Failed to cancel the contract
         *
         *     ### Notes
         *
         *     - By default (`permanent=False`), subscriptions are paused and can be reactivated later
         *     - When `permanent=True`, the subscription is permanently cancelled and cannot be reactivated
         *     - Cancellation metadata (reason, date) is stored on the contract for tracking
         */
        post: operations["cancel_subscription_v1_subscriptions_cancel_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/subscriptions/reactivate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reactivate Subscription
         * @description Reactivate a cancelled subscription.
         *
         *     Customers can reactivate their own cancelled subscriptions. The subscription
         *     must belong to the authenticated customer and be in PAUSED status.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `reactivate_request`: Reactivate request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse** containing:
         *
         *     - `subscription`: The reactivated subscription details
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         */
        post: operations["reactivate_subscription_v1_subscriptions_reactivate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/subscriptions/set-next-billing-date": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Set Next Billing Date
         * @description Change the next billing date of a subscription.
         *
         *     Customers can modify their own subscriptions. The subscription must belong to the authenticated customer.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `set_next_billing_date_request`: Changing next billing date request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse** containing:
         *
         *     - `subscription`: The modified subscription details
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         */
        post: operations["set_next_billing_date_v1_subscriptions_set_next_billing_date_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/subscriptions/skip-next-delivery": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Skip Next Delivery
         * @description Skip the next delivery for a subscription.
         *
         *     Customers can skip the next delivery for their own subscriptions. The subscription
         *     must belong to the authenticated customer.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `skip_next_delivery_request`: Skipping next delivery request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse** containing:
         *
         *     - `subscription`: The modified subscription details
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         */
        post: operations["skip_next_delivery_v1_subscriptions_skip_next_delivery_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/subscriptions/unskip-next-delivery": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Unskip Next Delivery
         * @description Unskip the next delivery for a subscription.
         *
         *     If the calculated billing date is in the past the operation will raise an Error which should be handled
         *     in the frontend (e.g. ask customer for another date that is in the future).
         *     Customers can skip the next delivery for their own subscriptions. The subscription
         *     must belong to the authenticated customer.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `unskip_next_delivery_request`: Skipping next delivery request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse** containing:
         *
         *     - `subscription`: The modified subscription details
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         *     - **HTTPException (500)**: Calculated date is in the past
         */
        post: operations["unskip_next_delivery_v1_subscriptions_unskip_next_delivery_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/subscriptions/ship-order-tomorrow": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Ship Order Tomorrow
         * @description Schedules the order for a subscription to tomorrow.
         *
         *     Customers can change their subscription to be shipped tomorrow. The subscription must belong to the authenticated
         *     customer. If the move_one_times_to_next_eligible_date parameter is set to True the one times on the subscription
         *     to ship_order_tomorrow will be moved to the next active subscription if there is any.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `ship_order_tomorrow_request`: ship order tomorrow request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse** containing:
         *
         *     - `subscription`: The modified subscription details
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         */
        post: operations["ship_order_tomorrow_v1_subscriptions_ship_order_tomorrow_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/subscriptions/charge-now": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Charge Now
         * @description Enqueue subscriptions for immediate charging.
         *
         *     Trigger an immediate charge for your subscriptions. The subscription must belong to the authenticated customer. The charge is processed asynchronously.
         *
         *     ### Args
         *
         *     - `subscription_ids`: List of your subscription IDs to charge immediately
         *     - `next_billing_date_reference`: How to calculate the next billing date after charging:
         *         - `"from_today"`: Next date = today + interval
         *         - `"original_next_billing_date"`: Next date = current next_billing_date + interval
         *         - `"leave_as_is"`: Don't change the next billing date
         *     - `notify_customer_about_failed_attempt`: Whether to email customer on failure (default: True)
         *
         *     ### Returns
         *
         *     **ChargeNowResponse** containing:
         *
         *     - `subscription_ids`: List of subscription IDs that have been enqueued for charging
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         *     - **HTTPException (500)**: Internal error during processing
         *
         *     ### Notes
         *
         *     - The charge is processed asynchronously and typically completes within 3-5 seconds
         *     - To verify the charge completed, poll the subscription to check if `next_billing_date` has been updated
         *     - Multiple subscriptions are bundled into a single charge
         */
        post: operations["charge_now_v1_subscriptions_charge_now_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/subscriptions/set-delivery-address": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Set Delivery Address
         * @description Change the delivery address of a subscription.
         *
         *     Customers can modify their own subscriptions. The subscription must belong to the authenticated customer.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `set_delivery_address_request`: Changing next delivery date request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse** containing:
         *
         *     - `subscription`: The modified subscription details
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         */
        post: operations["set_delivery_address_v1_subscriptions_set_delivery_address_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/subscriptions/set-delivery-interval": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Set Delivery Interval
         * @description Change the delivery interval of a subscription or a line item.
         *
         *     Customers can modify their own subscriptions. The subscription must belong to the authenticated customer.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `set_delivery_address_request`: Changing next delivery date request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse** containing:
         *
         *     - `subscription`: The modified subscription details
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         */
        post: operations["set_delivery_interval_v1_subscriptions_set_delivery_interval_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/subscriptions/change-payment-method": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Change payment method on subscription
         * @description Update the payment method used for billing a subscription contract
         */
        post: operations["change_payment_method_endpoint_v1_subscriptions_change_payment_method_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/subscriptions/request-payment-update-email": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request payment update email
         * @description Trigger Shopify to send a payment method update email to the customer
         */
        post: operations["request_payment_update_email_v1_subscriptions_request_payment_update_email_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/subscriptions/multi-update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Multi Update Subscription
         * @description Perform multiple subscription modifications in a single atomic operation.
         *
         *     This endpoint allows you to modify multiple aspects of your subscription at once: add, remove,
         *     or update products, and apply or remove discount codes. All changes are executed in parallel
         *     and committed atomically, so either all changes succeed or none are applied.
         *
         *     ### Args
         *
         *     - `subscription_id`: The subscription to modify
         *
         *         - Format: `gid://shopify/SubscriptionContract/123456789`
         *         - Example: `"gid://shopify/SubscriptionContract/116447871358"`
         *
         *     - `lines_to_add`: Products to add to your subscription
         *
         *         Each line item requires:
         *         - `product_variant_id`: The product variant to add (format: `gid://shopify/ProductVariant/123456789`)
         *         - `quantity`: Number of items (default: 1)
         *         - `selling_plan_id`: Subscription pricing plan (format: `gid://shopify/SellingPlan/123456789`, optional)
         *         - `custom_attributes`: Additional metadata as key-value pairs (optional)
         *
         *     - `lines_to_remove`: Line item IDs to remove from your subscription
         *
         *         - Format: `gid://shopify/SubscriptionLine/uuid`
         *         - Example: `["gid://shopify/SubscriptionLine/30bf89d8-9309-4477-98e5-2ea1e35d44a7"]`
         *         - Get these IDs from the `lines[].id` field in your subscription object
         *
         *     - `lines_to_update`: Line items to modify
         *
         *         For each update you can specify:
         *         - `line_item_id`: Which line to update (required, format: `gid://shopify/SubscriptionLine/uuid`)
         *         - `quantity`: New quantity (optional)
         *         - `product_variant_id`: Switch to a different product variant (optional, format: `gid://shopify/ProductVariant/123456789`)
         *         - `selling_plan_id`: Change the pricing plan (optional, format: `gid://shopify/SellingPlan/123456789`)
         *
         *     - `discount_codes_to_apply`: Promotional discount codes to apply
         *
         *         - Format: Plain string codes (NOT Shopify GIDs)
         *         - Example: `["WELCOME10", "DISCOUNT_10_PCT"]`
         *         - These are the promotional codes your customers enter at checkout
         *
         *     - `discount_codes_to_remove`: Discount IDs to remove
         *
         *         - Format: `gid://shopify/SubscriptionManualDiscount/uuid`
         *         - Example: `["gid://shopify/SubscriptionManualDiscount/a966faac-83bc-4ab1-ab98-fd2b289f14c0"]`
         *         - Get these IDs from the `discounts[].id` field in your subscription object
         *         - These are Shopify's internal discount IDs, NOT the promotional codes
         *
         *     ### Returns
         *
         *     **SubscriptionResponse** containing:
         *
         *     - `subscription`: Your fully updated subscription with all changes applied
         *
         *     ### Raises
         *
         *     - **HTTPException (400)**: No operations provided or invalid request
         *     - **HTTPException (403)**: You don't have access to this subscription
         *     - **HTTPException (500)**: Operation failed (Shopify error, invalid discount code, etc.)
         *
         *     ### Notes
         *
         *     - At least one operation must be provided
         *     - All operations execute in parallel for optimal performance
         *     - Changes are atomic - if any operation fails, none are applied
         *     - When applying discounts, use promotional codes (e.g., "SUMMER10")
         *     - When removing discounts, use Shopify discount IDs from the subscription's `discounts[].id` field
         *     - All IDs must use full Shopify GID format - no partial IDs or UUIDs alone
         */
        post: operations["multi_update_subscription_v1_subscriptions_multi_update_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/subscriptions/create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Subscription
         * @description Create a new subscription contract for a customer.
         *
         *     Creates a subscription contract in Shopify with the specified products, billing schedule,
         *     delivery address, and payment method.
         *
         *     **Note**: Customer ID, store, and currency are automatically derived from authentication and shop settings. Prices are always calculated server-side.
         *
         *     ### Args
         *
         *     - `lines`: List of products to include in the subscription:
         *
         *         - `product_variant_id`: The Shopify product variant ID
         *         - `quantity`: Quantity of this product
         *         - `selling_plan_id`: Selling plan ID (optional, see Price Calculation below)
         *         - `custom_attributes`: Custom attributes for the line item
         *
         *     - `next_billing_date`: Next billing date in `YYYY-MM-DD` format (must be in the future)
         *     - `interval`: Billing interval (`DAY`, `WEEK`, `MONTH`, `YEAR`)
         *     - `interval_count`: Number of intervals between billings (default: 1)
         *     - `payment_method_id`: Shopify customer payment method ID
         *     - `delivery_address`: Delivery address containing:
         *
         *         - `first_name`, `last_name`: Recipient name
         *         - `address1`, `address2`: Street address
         *         - `city`, `province`, `country`, `zip`: Location details
         *         - `phone`: Contact phone number
         *         - `country_code`: ISO country code (e.g., `DE`, `US`)
         *
         *     - `delivery_method_type`: `shipping` or `local_delivery` (default: `shipping`)
         *     - `discount_codes`: List of discount codes to apply (optional)
         *     - `custom_attributes`: Custom attributes for the contract (optional)
         *
         *     ### Price Calculation
         *
         *     Product prices are always calculated server-side:
         *
         *     1. **If `selling_plan_id` is provided**: Looks up the selling plan and applies its pricing policy
         *     2. **Otherwise**: Automatically finds a matching selling plan based on the subscription's
         *        `interval` and `interval_count`, then applies any discounts from that plan
         *
         *     When a selling plan is found, its pricing policy is applied to the variant's base price.
         *     For example, a selling plan with a 10% discount will reduce the variant price accordingly.
         *
         *     **Note**: Price overrides are not allowed in the storefront API for security reasons.
         *
         *     ### Delivery Price Calculation
         *
         *     Delivery price is always calculated server-side:
         *
         *     1. **If store config has `recalculate_shipping_rate_prior_to_charging=True`**: Sets to 0
         *        (delivery will be calculated at charge time)
         *     2. **Otherwise**: Calculates delivery rate using the store's delivery profiles based on
         *        the products and delivery address
         *
         *     ### Returns
         *
         *     **SubscriptionResponse** containing the created subscription contract with all its details.
         *
         *     ### Raises
         *
         *     - **HTTPException (400)**: Validation errors including:
         *
         *         - `InvalidDiscountCodeError`: Discount code does not exist or is not applicable to subscriptions
         *         - `InvalidPaymentMethodError`: Payment method is invalid or does not belong to the customer
         *         - `InvalidLineError`: Product variant does not exist
         *         - `InvalidBillingDateError`: Billing date is in the past
         *
         *     - **HTTPException (500)**: Internal server error
         *
         *     ### Notes
         *
         *     - Payment method must be valid and belong to the specified customer
         *     - Discount codes must be valid for subscriptions (one-time discounts will be rejected)
         *     - Custom attributes `source` and `created_by` are automatically added to the contract
         */
        post: operations["create_subscription_v1_subscriptions_create_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/line-items/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cancel Line Item
         * @description Cancel a line item for a customer's subscription.
         *
         *     Customers can cancel their own subscriptions. The subscription
         *     must belong to the authenticated customer. If the move_one_times_to_next_eligible_date parameter is set to True
         *     the one times on the subscription to cancel will be moved to the next active subscription if there is any.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `cancel_request`: Cancel request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse | SubscriptionWithOriginalResponse**:
         *
         *     - `SubscriptionResponse`: The default response, containing the modified `subscription`.
         *     - `SubscriptionWithOriginalResponse`: Returned if `cancel_request.return_base_subscription_when_splitting`
         *       is `True`. This object contains:
         *         - `subscription`: The contract that was paused (if no split) or the
         *           newly created contract containing the paused line item (if split).
         *         - `original_subscription`: If a split occurred, this is the original
         *           contract with the line item removed. Otherwise, `None`.
         *
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         */
        post: operations["cancel_line_item_v1_line_items_cancel_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/line-items/reactivate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Reactivate Subscription
         * @description Reactivate a cancelled subscription.
         *
         *     Customers can reactivate their own cancelled subscriptions. The subscription
         *     must belong to the authenticated customer and be in PAUSED status.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `reactivate_request`: Reactivate request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse | SubscriptionWithOriginalResponse**:
         *
         *     - `SubscriptionResponse`: The default response, containing the modified `subscription`.
         *     - `SubscriptionWithOriginalResponse`: Returned if `pause_request.return_base_subscription_when_splitting`
         *       is `True`. This object contains:
         *         - `subscription`: The contract that was paused (if no split) or the
         *           newly created contract containing the paused line item (if split).
         *         - `original_subscription`: If a split occurred, this is the original
         *           contract with the line item removed. Otherwise, `None`.
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         */
        post: operations["reactivate_subscription_v1_line_items_reactivate_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/line-items/set-next-billing-date": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Set Next Billing Date
         * @description Change the next billing date of a subscription.
         *
         *     Customers can modify their own subscriptions. The subscription must belong to the authenticated customer.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `set_next_billing_date_request`: Changing next billing date request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse | SubscriptionWithOriginalResponse**:
         *
         *     - `SubscriptionResponse`: The default response, containing the modified `subscription`.
         *     - `SubscriptionWithOriginalResponse`: Returned if `return_base_subscription_when_splitting`
         *       is `True`. This object contains:
         *         - `subscription`: The contract that was paused (if no split) or the
         *           newly created contract containing the paused line item (if split).
         *         - `original_subscription`: If a split occurred, this is the original
         *           contract with the line item removed. Otherwise, `None`.
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         */
        post: operations["set_next_billing_date_v1_line_items_set_next_billing_date_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/line-items/skip-next-delivery": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Skip Next Delivery
         * @description Skip the next delivery for a subscription.
         *
         *     Customers can skip the next delivery for their own subscriptions. The subscription
         *     must belong to the authenticated customer.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `skip_next_delivery_request`: Skipping next delivery request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse | SubscriptionWithOriginalResponse**:
         *
         *     - `SubscriptionResponse`: The default response, containing the modified `subscription`.
         *     - `SubscriptionWithOriginalResponse`: Returned if `return_base_subscription_when_splitting`
         *       is `True`. This object contains:
         *         - `subscription`: The contract that was paused (if no split) or the
         *           newly created contract containing the paused line item (if split).
         *         - `original_subscription`: If a split occurred, this is the original
         *           contract with the line item removed. Otherwise, `None`.
         *
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         */
        post: operations["skip_next_delivery_v1_line_items_skip_next_delivery_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/line-items/unskip-next-delivery": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Unskip Next Delivery
         * @description Unskip the next delivery for a subscription.
         *
         *     If the calculated billing date is in the past the operation will raise an Error which should be handled
         *     in the frontend (e.g. ask customer for another date that is in the future).
         *     Customers can skip the next delivery for their own subscriptions. The subscription
         *     must belong to the authenticated customer.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `skip_next_delivery_request`: Skipping next delivery request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse | SubscriptionWithOriginalResponse**:
         *
         *     - `SubscriptionResponse`: The default response, containing the modified `subscription`.
         *     - `SubscriptionWithOriginalResponse`: Returned if `return_base_subscription_when_splitting`
         *       is `True`. This object contains:
         *         - `subscription`: The contract that was paused (if no split) or the
         *           newly created contract containing the paused line item (if split).
         *         - `original_subscription`: If a split occurred, this is the original
         *           contract with the line item removed. Otherwise, `None`.
         *
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         *     - **HTTPException (500)**: Calculated date is in the past
         */
        post: operations["unskip_next_delivery_v1_line_items_unskip_next_delivery_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/line-items/ship-order-tomorrow": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Ship Order Tomorrow
         * @description Schedules the order for a subscription to tomorrow.
         *
         *     Customers can change their subscription to be shipped tomorrow. The subscription must belong to the authenticated
         *     customer. If the move_one_times_to_next_eligible_date parameter is set to True the one times on the subscription
         *     to ship_order_tomorrow will be moved to the next active subscription if there is any.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `ship_order_tomorrow_request`: ship order tomorrow request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse | SubscriptionWithOriginalResponse**:
         *
         *     - `SubscriptionResponse`: The default response, containing the modified `subscription`.
         *     - `SubscriptionWithOriginalResponse`: Returned if `return_base_subscription_when_splitting`
         *       is `True`. This object contains:
         *         - `subscription`: The contract that was paused (if no split) or the
         *           newly created contract containing the paused line item (if split).
         *         - `original_subscription`: If a split occurred, this is the original
         *           contract with the line item removed. Otherwise, `None`.
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         */
        post: operations["ship_order_tomorrow_v1_line_items_ship_order_tomorrow_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/line-items/change-product-quantity": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Change Product Quantity
         * @description Change the quantity product of a line item subscription.
         *
         *     Customers can change the quantity of a product in their subscription.
         *     The subscription must belong to the authenticated customer.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `change_product_quantity_request`: Change product quantity request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse** containing:
         *
         *     - `subscription`: The modified subscription
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         *     - **HTTPException (400)**: Invalid input - either variant or quantity must be present
         */
        post: operations["change_product_quantity_v1_line_items_change_product_quantity_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/line-items/change-product-variant": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Change Product Variant
         * @description Change the variant of product of a line item subscription.
         *
         *     Customers can change the variant of a product in their subscription.
         *     The subscription must belong to the authenticated customer.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `change_product_variant_request`: Change product variant request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse** containing:
         *
         *     - `subscription`: The modified subscription
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         *     - **HTTPException (400)**: Invalid input - either variant or quantity must be present
         */
        post: operations["change_product_variant_v1_line_items_change_product_variant_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/line-items/set-delivery-address": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Set Delivery Address
         * @description Change the delivery address of a subscription.
         *
         *     Customers can modify their own subscriptions. The subscription must belong to the authenticated customer.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `set_delivery_address_request`: Changing next delivery date request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse | SubscriptionWithOriginalResponse**:
         *
         *     - `SubscriptionResponse`: The default response, containing the modified `subscription`.
         *     - `SubscriptionWithOriginalResponse`: Returned if `return_base_subscription_when_splitting`
         *       is `True`. This object contains:
         *         - `subscription`: The contract that was paused (if no split) or the
         *           newly created contract containing the paused line item (if split).
         *         - `original_subscription`: If a split occurred, this is the original
         *           contract with the line item removed. Otherwise, `None`.
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         */
        post: operations["set_delivery_address_v1_line_items_set_delivery_address_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/line-items/set-delivery-interval": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Set Delivery Interval
         * @description Change the delivery interval of a line item within a subscription.
         *
         *     Customers can modify their own subscriptions. The subscription must belong to the authenticated customer.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `set_delivery_address_request`: Changing next delivery date request details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse | SubscriptionWithOriginalResponse**:
         *
         *     - `SubscriptionResponse`: The default response, containing the modified `subscription`.
         *     - `SubscriptionWithOriginalResponse`: Returned if `return_base_subscription_when_splitting`
         *       is `True`. This object contains:
         *         - `subscription`: The contract that was paused (if no split) or the
         *           newly created contract containing the paused line item (if split).
         *         - `original_subscription`: If a split occurred, this is the original
         *           contract with the line item removed. Otherwise, `None`.
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         */
        post: operations["set_delivery_interval_v1_line_items_set_delivery_interval_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/line-items/add": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add Line Item
         * @description Add a product to a subscription.
         *
         *     The price will be taken from the selling plan if selling_plan_id is provided. If no selling plan is provided
         *     it will take the price of the first selling plan for the product variant.
         *
         *     Customers can add line items to their subscription.
         *     The subscription must belong to the authenticated customer.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `add_line_item_request`: Add line item details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse** containing:
         *
         *     - `subscription`: The modified subscription
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         *     - **HTTPException (400)**: Invalid input - either variant or quantity must be present
         */
        post: operations["add_line_item_v1_line_items_add_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/line-items/remove": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Remove Line Item
         * @description Remove a product from a subscription.
         *
         *     Customers can remove line items from their subscription.
         *     The subscription must belong to the authenticated customer.
         *
         *     ### Args
         *
         *     - `request`: FastAPI request with JWT authentication context
         *     - `remove_line_item_request`: Remove Line item details
         *
         *     ### Returns
         *
         *     **SubscriptionResponse** containing:
         *
         *     - `subscription`: The modified subscription
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         *     - **HTTPException (400)**: Invalid input - either variant or quantity must be present
         */
        post: operations["remove_line_item_v1_line_items_remove_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/delivery-dates/location": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Location
         * @description Find the fulfillment location for a customer address.
         *
         *     Uses the customer's shipping address to determine the appropriate fulfillment
         *     location for delivery date calculations and logistics planning.
         *
         *     ### Args
         *
         *     - `address`: Customer shipping address containing:
         *         - `address1`: Street address (required)
         *         - `address2`: Apartment, suite, etc. (optional)
         *         - `city`: City name (required)
         *         - `province_code`: State/province code (optional)
         *         - `zip`: Postal or ZIP code (required)
         *         - `country_code`: ISO 3166 Alpha-2 country code, e.g., 'US', 'DE' (required)
         *
         *     ### Returns
         *
         *     **LocationResponse** containing:
         *
         *     - `location_id`: Shopify location ID in GID format
         *     - `location_name`: Human-readable location name
         *
         *     ### Raises
         *
         *     - **HTTPException (404)**: No matching fulfillment location found for the address
         *
         *     ### Notes
         *
         *     - Only locations configured in Eversubs and active in Shopify are considered
         *     - Location matching is based on store-specific order routing configuration
         */
        post: operations["get_location_v1_delivery_dates_location_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/delivery-dates/calendar": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Calendar
         * @description Get eligible billing and delivery dates calendar for a fulfillment location.
         *
         *     Returns a list of date pairs showing when delivery can be scheduled and
         *     when the corresponding charge will occur. Takes into account charge offset
         *     (lead time), blackout dates, cutoff times, and operating days.
         *
         *     ### Args
         *
         *     - `location_id`: Shopify location ID in GID format (from `/delivery-dates/location` endpoint)
         *
         *     ### Returns
         *
         *     **EligibleDatesCalendar** containing:
         *
         *     - `eligible_dates`: List of date pairs, each with:
         *         - `delivery_date`: When the order will be delivered
         *         - `corresponding_billing_date`: When the customer will be charged
         *
         *     ### Notes
         *
         *     - Only locations configured in Eversubs are supported
         *     - Dates are filtered based on:
         *         - Charge offset (lead time between billing and delivery)
         *         - Blackout dates (holidays, closures)
         *         - Operating days (location-specific)
         *         - Cutoff times (affects earliest eligible date)
         *     - Maximum date range is determined by location configuration (default 90 days)
         */
        post: operations["calendar_v1_delivery_dates_calendar_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customers/payment-methods": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get customer payment methods
         * @description Retrieve all payment methods associated with the authenticated customer
         */
        get: operations["get_payment_methods_v1_customers_payment_methods_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/churn-prevention/cancellation-reasons": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List cancellation reasons
         * @description Retrieve available cancellation reasons without offers.
         *
         *     Returns all cancellation reasons configured for the store. Customers must
         *     provide a valid subscription_id that belongs to them. To view offers for a specific
         *     reason, call the offers endpoint with the reason_id.
         *
         *     ### Args
         *
         *     - `subscription_id`: Shopify subscription contract ID (e.g., `gid://shopify/SubscriptionContract/123`)
         *
         *     ### Returns
         *
         *     **GetCancellationReasonsResponse** containing:
         *
         *     - `cancellation_reasons`: List of cancellation reasons (no offers):
         *         - `reason_id`: Unique identifier for the reason
         *         - `title`: Localized titles for the cancellation reason
         *         - `description`: Optional localized descriptions
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         *     - **HTTPException (404)**: No cancellation reasons configured for store
         *
         *     ### Notes
         *
         *     - Offers are not included - use GET /v1/cancellation-reasons/offers to retrieve offers for a specific reason
         *     - Frontend is responsible for language selection based on customer locale
         *     - This endpoint logs CANCELLATION_REASONS_VIEWED activity
         */
        get: operations["get_cancellation_reasons_v1_churn_prevention_cancellation_reasons_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/churn-prevention/offers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get retention offers
         * @description Retrieve retention offers for a selected cancellation reason.
         *
         *     Returns all available offers for the specified cancellation reason.
         *     This endpoint filters out offers that are still in cooldown period based on
         *     customer's previous acceptances.
         *
         *     ### Args
         *
         *     - `subscription_id`: Shopify subscription contract ID (e.g., `gid://shopify/SubscriptionContract/123`)
         *     - `reason_id`: The cancellation reason ID selected by the customer
         *
         *     ### Returns
         *
         *     **GetCancellationReasonOffersResponse** containing:
         *
         *     - `reason`: Complete cancellation reason with offers:
         *         - `reason_id`: Unique identifier for the reason
         *         - `title`: Localized titles for the cancellation reason
         *         - `description`: Optional localized descriptions
         *         - `offers`: List of retention offers:
         *             - `offer_id`: Unique identifier for the offer
         *             - `action`: The action to be performed (skip delivery, discount, etc.)
         *             - `title`: Localized titles for the offer
         *             - `description`: Optional localized descriptions
         *             - `conditions`: Optional conditions (not yet evaluated)
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer
         *     - **HTTPException (404)**: Cancellation reason not found or inactive
         *
         *     ### Notes
         *
         *     - Returns empty array if no offers are configured or all offers are filtered out
         *     - Only offers that are not in cooldown period are returned
         *     - Offers with `cooldown_days` are filtered based on last acceptance timestamp
         *     - Condition validation ensures customer meets offer eligibility requirements
         *     - Frontend is responsible for language selection based on customer locale
         *     - This endpoint logs CANCELLATION_REASON_SELECTED activity
         */
        get: operations["get_cancellation_reason_offers_v1_churn_prevention_offers_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/churn-prevention/accept-offer": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Accept retention offer
         * @description Accept a retention offer and execute the associated action.
         *
         *     After customer selects a retention offer, this endpoint validates the offer,
         *     executes the action (skip delivery, discount, etc.), and logs the acceptance.
         *
         *     ### Args
         *
         *     - `subscription_id`: Shopify subscription contract ID
         *     - `reason_id`: The cancellation reason ID
         *     - `offer_id`: The retention offer ID to accept
         *     - `action`: Action to execute with embedded parameters:
         *         - `AcceptSkipNextDeliveryAction`: Skip next delivery (no additional fields)
         *         - `AcceptDiscountAction`: Apply discount (optional `entitled_lines` for line-specific discounts)
         *         - `AcceptAddFreeOneTimeAction`: Add free item (variant_id from stored offer)
         *         - `AcceptOpenTicketAction`: Open support ticket (requires `ticket_text`)
         *         - `AcceptSetNextDeliveryDateAction`: Set delivery date (requires `next_delivery_date`)
         *         - `AcceptAlignNextBillingDatesAction`: Align multiple subscriptions (requires `alignments`)
         *         - `AcceptIncreaseQuantityReduceFrequencyAction`: Adjust all quantities and interval (requires `factor`)
         *
         *     ### Returns
         *
         *     **AcceptRetentionOfferResponse** containing:
         *
         *     - `subscription`: The updated subscription after applying the action
         *     - `action_result`: Action-specific details about what was changed
         *
         *     ### Raises
         *
         *     - **HTTPException (403)**: Subscription doesn't belong to customer, or unauthorized subscriptions in alignment
         *     - **HTTPException (404)**: Cancellation reason, offer, or line item not found
         *     - **HTTPException (400)**: Action execution failed or missing required parameters
         *     - **HTTPException (500)**: Offer action type mismatch
         *
         *     ### Notes
         *
         *     - Validates subscription ownership via JWT
         *     - Validates offer exists and action type matches before execution
         *     - Action type discriminator makes required fields self-documenting
         *     - Executes the retention action via Shopify API
         *     - Logs RETENTION_OFFER_ACCEPTED activity
         *     - Returns the updated subscription so frontend can display changes immediately
         *     - **OpenTicketAction**: Only logs the ticket information in activity logs
         *     - **AlignNextBillingDatesAction**: Can modify multiple subscriptions simultaneously, validates customer owns all subscriptions
         *     - **IncreaseQuantityReduceFrequencyAction**: Updates all subscription line quantities and delivery frequency proportionally
         */
        post: operations["accept_retention_offer_v1_churn_prevention_accept_offer_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * AcceptAddFreeOneTimeAction
         * @description Add free one-time item action for accept request.
         *
         *     The variant_id is configured in the offer stored in the database,
         *     not provided in the request payload.
         */
        AcceptAddFreeOneTimeAction: {
            /**
             * Type
             * @constant
             */
            type: "add_free_one_time";
        };
        /**
         * AcceptAlignNextBillingDatesAction
         * @description Align next billing dates action for accept request.
         *
         *     Payload is embedded directly in the action for self-documenting API.
         *     Allows aligning multiple subscriptions to shared billing dates to reduce shipping costs.
         */
        AcceptAlignNextBillingDatesAction: {
            /**
             * Type
             * @constant
             */
            type: "align_next_billing_dates";
            /**
             * Alignments
             * @description List of billing date alignments. Each alignment specifies a date and the subscriptions to align to it.
             */
            alignments: components["schemas"]["BillingDateAlignment"][];
        };
        /**
         * AcceptDiscountAction
         * @description Discount action for accept request.
         *
         *     Payload is embedded directly in the action for self-documenting API.
         */
        AcceptDiscountAction: {
            /**
             * Type
             * @constant
             */
            type: "discount";
            /**
             * Entitled Lines
             * @description Optional list of line item IDs to apply discount to. If None, applies to all lines.
             */
            entitled_lines?: string[] | null;
        };
        /**
         * AcceptIncreaseQuantityReduceFrequencyAction
         * @description Increase quantity and reduce frequency action for accept request.
         *
         *     Payload is embedded directly in the action for self-documenting API.
         *     Increases all line item quantities while proportionally reducing delivery frequency
         *     to maintain total monthly volume while reducing per-order shipping costs.
         */
        AcceptIncreaseQuantityReduceFrequencyAction: {
            /**
             * Type
             * @constant
             */
            type: "increase_quantity_reduce_frequency";
            /**
             * Factor
             * @description Multiplication factor for both quantity and interval. For example, factor=2 doubles all quantities and doubles delivery interval.
             */
            factor: number;
        };
        /**
         * AcceptOpenTicketAction
         * @description Open ticket action for accept request.
         *
         *     Payload is embedded directly in the action for self-documenting API.
         */
        AcceptOpenTicketAction: {
            /**
             * Type
             * @constant
             */
            type: "open_ticket";
            /**
             * Ticket Text
             * @description Text content for the support ticket
             */
            ticket_text: string;
        };
        /**
         * AcceptRetentionOfferRequest
         * @description Request to accept a retention offer.
         *
         *     This request is made after customer selects a specific retention offer
         *     from the list retrieved via the get-offers endpoint.
         *
         *     The action field contains the action type with embedded payload parameters,
         *     making the required fields self-documenting in the API specification.
         */
        AcceptRetentionOfferRequest: {
            /**
             * Subscription Id
             * @description Shopify subscription contract ID (e.g., gid://shopify/SubscriptionContract/123)
             */
            subscription_id: string;
            /**
             * Reason Id
             * @description Cancellation reason ID from the GET /churn-prevention/cancellation-reasons endpoint
             */
            reason_id: string;
            /**
             * Offer Id
             * @description Retention offer ID from the GET /churn-prevention/offers endpoint
             */
            offer_id: string;
            /**
             * Action
             * @description Action to execute with embedded payload parameters. Type discriminates which action and shows required fields in API docs.
             */
            action: components["schemas"]["AcceptSkipNextDeliveryAction"] | components["schemas"]["AcceptDiscountAction"] | components["schemas"]["AcceptAddFreeOneTimeAction"] | components["schemas"]["AcceptOpenTicketAction"] | components["schemas"]["AcceptSetNextDeliveryDateAction"] | components["schemas"]["AcceptAlignNextBillingDatesAction"] | components["schemas"]["AcceptIncreaseQuantityReduceFrequencyAction"];
        };
        /**
         * AcceptRetentionOfferResponse
         * @description Response after accepting a retention offer.
         */
        AcceptRetentionOfferResponse: {
            subscription: components["schemas"]["SubscriptionContractFull"];
            /** Action Result */
            action_result: {
                [key: string]: unknown;
            };
        };
        /**
         * AcceptSetNextDeliveryDateAction
         * @description Set next delivery date action for accept request.
         *
         *     Payload is embedded directly in the action for self-documenting API.
         */
        AcceptSetNextDeliveryDateAction: {
            /**
             * Type
             * @constant
             */
            type: "set_next_delivery_date";
            /**
             * Next Delivery Date
             * @description ISO 8601 date string for next delivery
             */
            next_delivery_date: string;
        };
        /**
         * AcceptSkipNextDeliveryAction
         * @description Skip next delivery action for accept request.
         */
        AcceptSkipNextDeliveryAction: {
            /**
             * Type
             * @constant
             */
            type: "skip_next_delivery";
        };
        /**
         * ActiveContractCountCondition
         * @description Condition based on number of active subscription contracts.
         */
        ActiveContractCountCondition: {
            /**
             * Type
             * @constant
             */
            type: "active_contract_count";
            /** Amount */
            amount: number;
            /**
             * Operand
             * @enum {string}
             */
            operand: "eq" | "neq" | "gt" | "lt";
        };
        /**
         * ActiveProductCountCondition
         * @description Condition based on number of unique active subscription products.
         */
        ActiveProductCountCondition: {
            /**
             * Type
             * @constant
             */
            type: "active_product_count";
            /** Amount */
            amount: number;
            /**
             * Operand
             * @enum {string}
             */
            operand: "eq" | "neq" | "gt" | "lt";
        };
        /**
         * AddFreeOneTimeAction
         * @description Add a free one-time item to next order.
         *
         *     Adds a product variant as a one-time add-on to the customer's next delivery
         *     at no charge. The item is added only once and won't recur.
         *
         *     ### Configuration Parameters
         *
         *     - `variant_id`: Shopify product variant ID to add as free sample
         *         - Must be a valid variant in your store
         *         - Customer cannot modify this - configured in UI only
         *
         *     ### Example Use Cases
         *
         *     - Product sampling: Let customer try a new product flavor
         *     - Apology gift: Compensate for service issues
         *     - Upsell incentive: Give free sample to encourage adding to subscription
         *     - Loyalty reward: Thank long-term customers with free item
         */
        AddFreeOneTimeAction: {
            /**
             * Type
             * @constant
             */
            type: "add_free_one_time";
            /**
             * Variant Id
             * @description Shopify variant ID for the free item to add
             */
            variant_id: string;
        };
        /**
         * Address
         * @description Shipping address information.
         */
        Address: {
            /**
             * Address1
             * @description First line of the address
             */
            address1?: string | null;
            /**
             * Address2
             * @description Second line of the address
             */
            address2?: string | null;
            /**
             * Zip
             * @description ZIP code
             */
            zip?: string | null;
            /**
             * City
             * @description City
             */
            city?: string | null;
            /**
             * Company
             * @description Company name
             */
            company?: string | null;
            /**
             * Country
             * @description Country
             */
            country?: string | null;
            /**
             * Country Code
             * @description Country code
             */
            country_code?: string | null;
            /**
             * Province Code
             * @description Province code. For some countries this is mandatory when creating a contract
             */
            province_code?: string | null;
            /**
             * First Name
             * @description First name
             */
            first_name?: string | null;
            /**
             * Last Name
             * @description Last name
             */
            last_name?: string | null;
            /**
             * Name
             * @description Full name
             */
            name?: string | null;
            /**
             * Phone
             * @description Phone number. Must be present when using local delivery.
             */
            phone?: string | null;
        };
        /**
         * AlignNextBillingDatesAction
         * @description Align multiple subscriptions to shared billing dates.
         *
         *     Consolidates multiple subscriptions to common billing dates, reducing
         *     per-order shipping costs and simplifying delivery management for customers.
         *
         *     ### Configuration Parameters
         *
         *     No configuration needed - customer provides alignment configuration in accept request.
         *
         *     ### Customer Request Required
         *
         *     Customer must provide the alignment configuration specifying which subscriptions
         *     to align to which dates when accepting the offer. Each alignment contains:
         *     - `next_billing_date`: Target date to align subscriptions to
         *     - `subscription_ids`: List of subscription IDs to align to that date
         *
         *     ### Security
         *
         *     System validates customer owns all subscriptions in alignment request to prevent
         *     unauthorized cross-customer modifications.
         *
         *     ### Example Use Cases
         *
         *     - Shipping cost optimization: Combine 4 weekly subscriptions into 2 bi-weekly shipments
         *     - Delivery convenience: Ensure all products arrive on same day
         *     - Budget management: Consolidate billing to specific dates
         */
        AlignNextBillingDatesAction: {
            /**
             * Type
             * @constant
             */
            type: "align_next_billing_dates";
        };
        /**
         * BaseChargeNowRequest
         * @description Base Request model for charging subscriptions immediately.
         */
        BaseChargeNowRequest: {
            /**
             * Subscription Ids
             * @description The base subscription IDs that should be charged now, irrespective of next charge date. These are in Shopify format, e.g. gid://shopify/SubscriptionContract/3259072718
             */
            subscription_ids?: string[] | null;
            /**
             * Next Billing Date Reference
             * @description After successfully charging the contract, calculate the next charge date either starting from today (i.e. today + interval), starting from next billing date (i.e. next_billing_date + interval) or simply leave it unchanged (leave_as_is)
             * @default original_next_billing_date
             * @enum {string}
             */
            next_billing_date_reference: "today" | "original_next_billing_date" | "leave_next_billing_date_unchanged";
            /**
             * Notify Customer About Failed Attempt
             * @description Specifies if customer should be informed about a failed attempt and be prompted to update their payment method
             * @default true
             */
            notify_customer_about_failed_attempt: boolean | null;
            /**
             * Caused By
             * @description Mandatory field for audit trail. Allows to override the triggered by field in logs to make sure that the logs reflect who actually did it.
             * @default Subscription Charge Now API
             */
            caused_by: string;
        };
        /**
         * BaseCustomDiscount
         * @description Base model for custom discounts.
         */
        BaseCustomDiscount: {
            /** Title */
            title: string;
            /** Value */
            value: number;
            /**
             * Value Type
             * @enum {string}
             */
            value_type: "PERCENTAGE" | "FIXED";
            /**
             * Once Per Order
             * @default true
             */
            once_per_order: boolean;
            conditions?: components["schemas"]["DiscountConditions"] | null;
        };
        /**
         * BaseSubscriptionLineInput
         * @description Base input model for subscription line items in API requests.
         *
         *     Foundation for API endpoints that create or modify subscription line items.
         *     Contains core fields needed for any line item operation.
         */
        BaseSubscriptionLineInput: {
            /**
             * Product Variant Id
             * @description Shopify product variant ID
             */
            product_variant_id: string;
            /**
             * Selling Plan Id
             * @description Selling plan ID for subscription items
             */
            selling_plan_id?: string | null;
            /**
             * Quantity
             * @description Quantity of the item
             * @default 1
             */
            quantity: number;
            /**
             * Custom Attributes
             * @description Custom attributes for the line item
             */
            custom_attributes?: components["schemas"]["CustomAttribute"][] | null;
            /**
             * Type
             * @description Distinction on whether the new product should only be added to the next upcoming order as a one time or as a reagular subscription product
             * @default subscription
             */
            type: ("one_time" | "subscription") | null;
        };
        /**
         * BillingDateAlignment
         * @description Configuration for aligning subscriptions to a specific billing date.
         */
        BillingDateAlignment: {
            /**
             * Next Billing Date
             * @description ISO 8601 date string for the aligned billing date
             */
            next_billing_date: string;
            /**
             * Subscription Ids
             * @description List of subscription IDs to align to this date
             */
            subscription_ids: string[];
        };
        /**
         * BillingPolicy
         * @description Billing policy with interval and frequency.
         */
        BillingPolicy: {
            /**
             * Interval
             * @description The frequency, it can be either: DAY, WEEK, MONTH or YEAR.
             */
            interval: string;
            /**
             * Interval Count
             * @description The number of intervals between each step in the given interval unit.
             */
            interval_count: number;
        };
        /**
         * CalendarRequest
         * @description Base request model for getting eligible delivery dates.
         */
        CalendarRequest: {
            /**
             * Location Id
             * @description Shopify location ID (GID format)
             */
            location_id: string;
        };
        /**
         * CancellationReason
         * @description A cancellation reason with associated retention offers.
         */
        CancellationReason: {
            /** Reason Id */
            reason_id: string;
            /**
             * Title
             * @description Localized reason title. Object with language codes as keys (e.g., 'en', 'de', 'nl') and translated text as values. Type: dict[str, str]
             * @example {
             *       "de": "Zu teuer",
             *       "en": "Too expensive",
             *       "nl": "Te duur"
             *     }
             */
            title: {
                [key: string]: string;
            };
            /**
             * Description
             * @description Localized reason description. Object with language codes as keys (e.g., 'en', 'de', 'nl') and translated text as values. Type: dict[str, str]
             * @example {
             *       "de": "Wir verstehen Budgetbedenken",
             *       "en": "We understand budget concerns",
             *       "nl": "We begrijpen budgetzorgen"
             *     }
             */
            description?: {
                [key: string]: string;
            } | null;
            /**
             * Tags
             * @description Optional tags for categorization. Can be used in frontend for filtering and analytics.
             * @example [
             *       "first_order",
             *       "high_value"
             *     ]
             * @example [
             *       "frequent_canceller"
             *     ]
             */
            tags?: string[] | null;
            /** Offers */
            offers: components["schemas"]["RetentionOffer"][];
            /**
             * Active
             * @description Whether this cancellation reason is active and should be shown to customers. Defaults to True for backward compatibility.
             * @default true
             */
            active: boolean;
        };
        /**
         * CancellationReasonSummary
         * @description Cancellation reason summary without offers.
         */
        CancellationReasonSummary: {
            /** Reason Id */
            reason_id: string;
            /**
             * Title
             * @description Localized reason title. Object with language codes as keys (e.g., 'en', 'de', 'nl') and translated text as values. Type: dict[str, str]
             * @example {
             *       "de": "Zu teuer",
             *       "en": "Too expensive",
             *       "nl": "Te duur"
             *     }
             */
            title: {
                [key: string]: string;
            };
            /**
             * Description
             * @description Localized reason description. Object with language codes as keys (e.g., 'en', 'de', 'nl') and translated text as values. Type: dict[str, str]
             * @example {
             *       "de": "Wir verstehen Budgetbedenken",
             *       "en": "We understand budget concerns",
             *       "nl": "We begrijpen budgetzorgen"
             *     }
             */
            description?: {
                [key: string]: string;
            } | null;
            /**
             * Tags
             * @description Optional tags for categorization. Can be used in frontend for filtering and analytics.
             * @example [
             *       "first_order",
             *       "high_value"
             *     ]
             * @example [
             *       "frequent_canceller"
             *     ]
             */
            tags?: string[] | null;
        };
        /**
         * ChangePaymentMethodRequest
         * @description Request model for changing payment method on a subscription.
         */
        ChangePaymentMethodRequest: {
            /**
             * Subscription Id
             * @description Shopify subscription contract ID (e.g., 'gid://shopify/SubscriptionContract/...')
             */
            subscription_id: string;
            /**
             * Payment Method Id
             * @description Shopify payment method ID (e.g., 'gid://shopify/CustomerPaymentMethod/...')
             */
            payment_method_id: string;
        };
        /**
         * ChargeNowResponse
         * @description Response model for charge-now endpoints.
         */
        ChargeNowResponse: {
            /**
             * Subscription Ids
             * @description List of subscription IDs that have been enqueued for charging
             */
            subscription_ids: string[];
        };
        /**
         * ContractDiscounts
         * @description Contract-specific discount information.
         */
        ContractDiscounts: {
            /**
             * Id
             * @description Shopify GID of the discount
             */
            id: string;
            /**
             * Recurring Cycle Limit
             * @description Number of times the discount can be applied on recurring orders
             */
            recurring_cycle_limit?: number | null;
            /**
             * Rejection Reason
             * @description Rejection reason if the discount is not valid anymore.
             */
            rejection_reason?: string | null;
            /**
             * Type
             * @description type of the discount. Can be AUTOMATIC_DISCOUNT, CODE_DISCOUNT or MANUAL
             */
            type: string;
            /**
             * Is Active
             * @description TRUE=discount is still active, FALSE=discount is not active anymore.
             */
            is_active: boolean;
            /**
             * Title
             * @description Title of the discount
             */
            title: string;
            /**
             * Usage Count
             * @description Number of times the discount has already been applied on recurring orders
             */
            usage_count: number;
            /**
             * Value
             * @description for percentage discounts -> value between 1-100, for fixed discounts = discount amount
             */
            value: number;
            /**
             * Value Type
             * @enum {string}
             */
            value_type: "PERCENTAGE" | "FIXED";
        };
        /**
         * ContractLine
         * @description Product line item within a subscription contract.
         *
         *     Represents a single product/variant that's part of a subscription.
         *     Extends Product with:
         *     - Line item ID for contract management
         *     - Title for display
         *     - Custom attributes for metadata
         *     - Current pricing for billing
         *
         *     Used in SubscriptionContractWithLines for tracking all products
         *     in a customer's subscription.
         */
        ContractLine: {
            /**
             * Product Id
             * @description Shopify GID of the product. e.g. gid://shopify/Product/XXX
             */
            product_id?: string | null;
            /**
             * Variant Id
             * @description Shopify GID of the variant. e.g. gid://shopify/ProductVariant/XXX
             */
            variant_id?: string | null;
            /**
             * Quantity
             * @description Ordered quantity of the product.
             */
            quantity?: number | null;
            /** @description Discounted price of the line */
            line_discounted_price?: components["schemas"]["Price"] | null;
            /**
             * Id
             * @description the shopify GID of the line of the contract.
             */
            id: string;
            /**
             * Title
             * @description the title of the line of the contract item
             */
            title: string;
            /**
             * Custom Attributes
             * @description Custom attributes of the contract item
             */
            custom_attributes?: components["schemas"]["CustomAttribute"][] | null;
            /** @description Current price of the contract item */
            current_price?: components["schemas"]["Price"] | null;
            /**
             * Variant Title
             * @description The title of the variant
             */
            variant_title?: string | null;
            /**
             * Variant Image
             * @description Link to the image of the variant
             */
            variant_image?: string | null;
        };
        /**
         * CustomAttribute
         * @description Custom attribute for line items and contracts.
         */
        CustomAttribute: {
            /**
             * Key
             * @description key of the custom attribute. e.g. one_time_add_on
             */
            key: string | null;
            /**
             * Value
             * @description value of the custom attribute. e.g. TRUE/FALSE
             */
            value: string | null;
        };
        /**
         * CustomDiscount
         * @description Represents a complete discount sequence.
         *
         *     It automatically sorts steps before validation, making it robust against unordered input.
         */
        CustomDiscount: {
            /**
             * Discount Id
             * @description shopify GID of the discount that the custom discount config belongs to
             */
            discount_id?: string | null;
            /**
             * Title
             * @description Discount title that was setup in eversubs admin
             */
            title?: string | null;
            /**
             * Description
             * @description Discount description that was setup in eversubs admin
             */
            description?: string | null;
            /**
             * Discount Classes
             * @description accepted values: ORDER, PRODUCT, SHIPPING
             */
            discount_classes?: string[] | null;
            /** @description accepted values: ORDER, PRODUCT, SHIPPING */
            initial_discount?: components["schemas"]["BaseCustomDiscount"] | null;
            /** Steps */
            steps?: components["schemas"]["DiscountStep"][];
            /**
             * Is Active
             * @description whether there is any active step on the discount
             * @default false
             */
            is_active: boolean;
        };
        /**
         * Customer
         * @description Customer model with extended information including discounts and bundling preferences.
         */
        Customer: {
            /**
             * Id
             * @description the shopify GID of the customer associated with the contract.
             */
            id: string;
            /**
             * Email
             * @description email of customer
             */
            email?: string | null;
            /**
             * First Name
             * @description first name of customer
             */
            first_name?: string | null;
            /**
             * Automatically Bundle Subscriptions
             * @description whether or not customer has bundling enabled. This will only be false if customer or customer support agent sets this metafield
             * @default true
             */
            automatically_bundle_subscriptions: boolean | null;
            /**
             * Customer Discounts
             * @description Manual discounts on the customer that will be applied to subscription orders if valid
             * @default []
             */
            customer_discounts: components["schemas"]["CustomDiscount"][] | null;
        };
        /**
         * CustomerMetafieldCondition
         * @description Condition based on customer metafield value.
         */
        CustomerMetafieldCondition: {
            /**
             * Type
             * @constant
             */
            type: "customer_metafield";
            /** Namespace */
            namespace: string;
            /** Key */
            key: string;
            /** Expected Value */
            expected_value: string | number;
            /**
             * Operand
             * @enum {string}
             */
            operand: "eq" | "neq" | "gt" | "lt";
        };
        /**
         * CustomerPaymentMethod
         * @description Customer payment method information.
         */
        CustomerPaymentMethod: {
            /**
             * Id
             * @description the shopify GID of the customer payment method.
             */
            id?: string | null;
            /** @description Details about the payment method */
            instrument?: components["schemas"]["PaymentInstrument"] | null;
        };
        /**
         * DeliveryBillingDatePair
         * @description Pair of delivery and billing dates.
         */
        DeliveryBillingDatePair: {
            /**
             * Delivery Date
             * Format: date
             * @description An eligible delivery date for a specific location
             */
            delivery_date: string;
            /**
             * Corresponding Billing Date
             * Format: date
             * @description The corresponding billing date to the eligible delivery date. This is taking the location and day specific charge offset as well as deliverable days (by available weekdays and black out days) into consideration
             */
            corresponding_billing_date: string;
        };
        /**
         * DeliveryMethod
         * @description Delivery method with type, address and title.
         */
        DeliveryMethod: {
            /**
             * Type
             * @description Whether its using shipping or local delivery as a method.
             * @enum {string}
             */
            type: "shipping" | "local_delivery";
            /**
             * Phone
             * @description If type is local delivery the phone number must be present.
             */
            phone?: string | null;
            /** @description Shipping or local delivery method */
            address?: components["schemas"]["Address"] | null;
            /**
             * Title
             * @description Title of the delivery method. e.g. Kostenloser Versand / Standard Shipping
             * @default
             */
            title: string | null;
        };
        /**
         * DeliveryPolicy
         * @description Delivery policy with interval and frequency.
         *
         *     Fields are optional to handle non-recurring delivery policies (e.g., SellingPlanFixedDeliveryPolicy)
         *     which return empty objects from Shopify's GraphQL API.
         */
        DeliveryPolicy: {
            /**
             * Interval
             * @description The frequency, it can be either: DAY, WEEK, MONTH or YEAR.
             */
            interval?: string | null;
            /**
             * Interval Count
             * @description The number of intervals between each step in the given interval unit.
             */
            interval_count?: number | null;
        };
        /**
         * DiscountAction
         * @description Apply a percentage discount to subscription.
         *
         *     Reduces the subscription price by a specified percentage for a limited
         *     or unlimited number of billing cycles.
         *
         *     ### Configuration Parameters
         *
         *     - `percent`: Discount percentage (e.g., 20.0 for 20% off)
         *     - `duration_cycles`: Number of billing cycles to apply discount (optional)
         *         - If `None`: Discount applies indefinitely
         *         - If specified: Discount expires after N cycles
         *
         *     ### Customer Request Options
         *
         *     When accepting this offer, customers can optionally specify which line items
         *     to apply the discount to via `entitled_lines` in the request payload.
         *
         *     ### Example Use Cases
         *
         *     - Price objection: Offer 15% off for 3 months
         *     - Loyalty reward: Give 10% off permanently for long-term customers
         *     - Competitive retention: Match competitor pricing temporarily
         */
        DiscountAction: {
            /**
             * Type
             * @constant
             */
            type: "discount";
            /** Percent */
            percent: number;
            /** Duration Cycles */
            duration_cycles?: number | null;
        };
        /**
         * DiscountConditions
         * @description Conditions for applying discounts.
         */
        DiscountConditions: {
            /** @description only apply discount if order value exceeds minimum order value. */
            minimum_order_value?: components["schemas"]["MinumumOrderValue"] | null;
            /**
             * Apply To Collections
             * @description List of collection ids that the discount should be applied to
             * @default []
             */
            apply_to_collections: string[] | null;
            /**
             * Apply To Products
             * @description List of collection ids that the discount should be applied to
             * @default []
             */
            apply_to_products: string[] | null;
            /**
             * Apply To Product Variants
             * @description List of collection ids that the discount should be applied to
             * @default []
             */
            apply_to_product_variants: string[] | null;
            /**
             * Must Include Products
             * @description List of product ids that need to be present to apply the discount
             * @default []
             */
            must_include_products: string[] | null;
        };
        /**
         * DiscountStep
         * @description Discount step for progressive discounts.
         */
        DiscountStep: {
            /** Title */
            title: string;
            /** Value */
            value: number;
            /**
             * Value Type
             * @enum {string}
             */
            value_type: "PERCENTAGE" | "FIXED";
            /**
             * Once Per Order
             * @default true
             */
            once_per_order: boolean;
            conditions?: components["schemas"]["DiscountConditions"] | null;
            /** Step */
            step: number;
            /** Recurring Cycle Limit */
            recurring_cycle_limit: number;
            /**
             * Usage Count
             * @default 0
             */
            usage_count: number;
            /** Rejection Reason */
            rejection_reason?: string | null;
            /**
             * Is Active
             * @description whether this step is active
             * @default false
             */
            is_active: boolean;
        };
        /**
         * EligibleDatesCalendar
         * @description Calendar of eligible delivery dates with corresponding billing dates.
         */
        EligibleDatesCalendar: {
            /** Eligible Dates */
            eligible_dates: components["schemas"]["DeliveryBillingDatePair"][];
        };
        /**
         * GetCancellationReasonOffersResponse
         * @description Response containing a single cancellation reason with its offers.
         */
        GetCancellationReasonOffersResponse: {
            reason: components["schemas"]["CancellationReason"];
        };
        /**
         * GetCancellationReasonsResponse
         * @description Response containing cancellation reasons without offers.
         */
        GetCancellationReasonsResponse: {
            /** Cancellation Reasons */
            cancellation_reasons: components["schemas"]["CancellationReasonSummary"][];
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * IncreaseQuantityReduceFrequencyAction
         * @description Increase quantity and reduce frequency proportionally to reduce per-order shipping costs.
         *
         *     Automatically applies a multiplication factor to all subscription line item
         *     quantities and the delivery interval, maintaining total monthly volume while
         *     reducing per-order costs.
         *
         *     ### Configuration Parameters
         *
         *     No configuration needed - customer provides factor in accept request.
         *
         *     ### Customer Request Required
         *
         *     Customer must provide `factor` (float > 1.0) when accepting:
         *     - Factor of 2.0: Doubles quantities and delivery interval
         *     - Factor of 1.5: 50% increase in both
         *     - Factor of 3.0: Triples quantities and interval
         *
         *     ### Behavior
         *
         *     - Applies to ALL subscription line items (not one-time items)
         *     - Maintains product ratios (e.g., 2:3 ratio becomes 4:6 with factor 2.0)
         *     - Updates delivery interval proportionally
         *
         *     ### Example
         *
         *     Before (factor 2.0):
         *     - Product A: 2 units, Product B: 3 units
         *     - Delivery: Every 4 weeks
         *
         *     After:
         *     - Product A: 4 units, Product B: 6 units
         *     - Delivery: Every 8 weeks
         *
         *     ### Example Use Cases
         *
         *     - Shipping cost concerns: Reduce frequency to lower per-order shipping
         *     - Bulk discount preference: Order more at once for better unit pricing
         *     - Storage capacity: Customer has space for larger orders
         *     - Usage patterns: Customer uses product slower than anticipated
         */
        IncreaseQuantityReduceFrequencyAction: {
            /**
             * Type
             * @constant
             */
            type: "increase_quantity_reduce_frequency";
        };
        /**
         * LifetimeOrdersCondition
         * @description Condition based on customer's lifetime subscription order count.
         */
        LifetimeOrdersCondition: {
            /**
             * Type
             * @constant
             */
            type: "life_time_subscription_orders";
            /** Amount */
            amount: number;
            /**
             * Operand
             * @enum {string}
             */
            operand: "eq" | "neq" | "gt" | "lt";
        };
        /**
         * LifetimeSpentCondition
         * @description Condition based on customer's lifetime subscription spend amount.
         */
        LifetimeSpentCondition: {
            /**
             * Type
             * @constant
             */
            type: "life_time_subscription_spent";
            /** Amount */
            amount: number;
            /**
             * Operand
             * @enum {string}
             */
            operand: "eq" | "neq" | "gt" | "lt";
        };
        /**
         * LineUpdateInput
         * @description Input for updating an existing subscription line item.
         */
        LineUpdateInput: {
            /**
             * Line Item Id
             * @description The line item ID to update
             */
            line_item_id: string;
            /**
             * Quantity
             * @description New quantity for the line item
             */
            quantity?: number | null;
            /**
             * Product Variant Id
             * @description New product variant ID
             */
            product_variant_id?: string | null;
            /**
             * Selling Plan Id
             * @description New selling plan ID
             */
            selling_plan_id?: string | null;
        };
        /**
         * LocationRequest
         * @description Base request model for finding a fulfillment location.
         */
        LocationRequest: {
            /** @description Customer shipping address to find the fulfillment location for */
            address: components["schemas"]["Address"];
        };
        /**
         * LocationResponse
         * @description Response model for fulfillment location lookup.
         */
        LocationResponse: {
            /**
             * Location Id
             * @description Shopify location ID (GID format)
             */
            location_id: string;
            /**
             * Location Name
             * @description Human-readable location name
             */
            location_name: string;
        };
        /**
         * MinumumOrderValue
         * @description Minimum order value for discount conditions.
         */
        MinumumOrderValue: {
            /** Amount */
            amount: number;
            /** Currency */
            currency: string;
        };
        /**
         * OpenTicketAction
         * @description Open a support ticket.
         *
         *     Logs the customer's issue for follow-up by support team. The ticket text
         *     is provided by the customer when accepting the offer.
         *
         *     ### Configuration Parameters
         *
         *     No configuration needed - ticket text is provided in the accept request.
         *
         *     ### Customer Request Required
         *
         *     Customer must provide `ticket_text` when accepting this offer to describe
         *     their issue or concern.
         *
         *     ### Example Use Cases
         *
         *     - Complex issues: Customer needs human assistance beyond self-service
         *     - Product quality concerns: Log issue for investigation
         *     - Custom requests: Handle special cases that need manual review
         *     - Feedback collection: Gather detailed cancellation reasons
         */
        OpenTicketAction: {
            /**
             * Type
             * @constant
             */
            type: "open_ticket";
        };
        /**
         * PaymentInstrument
         * @description Payment instrument infos. Differs between paypal, card and shop pay.
         */
        PaymentInstrument: {
            /**
             * Name
             * @description The name of the payment instrument
             */
            name?: string | null;
            /**
             * Paypal Account Email
             * @description If paypal is the instrument, paypal email.
             */
            paypal_account_email?: string | null;
            /**
             * Last Digits
             * @description The last digits number of the card if it is card payment.
             */
            last_digits?: number | null;
            /**
             * Masked Number
             * @description The masked number of the card if it is card payment.
             */
            masked_number?: string | null;
            /**
             * Brand
             * @description The brand of the card if it is card payment.
             */
            brand?: string | null;
            /**
             * Expiry Month
             * @description The expiration month of the card if it is card payment.
             */
            expiry_month?: number | null;
            /**
             * Expiry Year
             * @description The expiration month of the card if it is card payment.
             */
            expiry_year?: number | null;
            /**
             * Source
             * @description The source of the payment instrument for credit cards.
             */
            source?: string | null;
            /** @description Billing address associated with this payment method */
            billing_address?: components["schemas"]["Address"] | null;
        };
        /**
         * PaymentMethodsResponse
         * @description Response model for customer payment methods.
         */
        PaymentMethodsResponse: {
            /**
             * Payment Methods
             * @description List of payment methods with instruments and billing addresses
             */
            payment_methods: components["schemas"]["CustomerPaymentMethod"][];
        };
        /**
         * Price
         * @description Price information with currency and amount.
         */
        Price: {
            /**
             * Currency Code
             * @description Currency code for the price
             */
            currency_code: string;
            /**
             * Amount
             * @description Amount of the price
             */
            amount: number;
        };
        /**
         * RequestPaymentUpdateEmailRequest
         * @description Request model for triggering payment update email.
         */
        RequestPaymentUpdateEmailRequest: {
            /**
             * Payment Method Id
             * @description Shopify payment method ID (e.g., 'gid://shopify/CustomerPaymentMethod/...')
             */
            payment_method_id: string;
        };
        /**
         * RequestPaymentUpdateEmailResponse
         * @description Response model for payment update email trigger.
         */
        RequestPaymentUpdateEmailResponse: {
            /**
             * Message
             * @description Success message confirming email was sent
             */
            message: string;
        };
        /**
         * RetentionOffer
         * @description A retention offer with action and conditions.
         */
        RetentionOffer: {
            /** Offer Id */
            offer_id: string;
            /** Action */
            action: components["schemas"]["SkipNextDeliveryAction"] | components["schemas"]["DiscountAction"] | components["schemas"]["AddFreeOneTimeAction"] | components["schemas"]["OpenTicketAction"] | components["schemas"]["SetNextDeliveryDateAction"] | components["schemas"]["AlignNextBillingDatesAction"] | components["schemas"]["IncreaseQuantityReduceFrequencyAction"];
            /**
             * Title
             * @description Localized offer title. Object with language codes as keys (e.g., 'en', 'de', 'nl') and translated text as values. Type: dict[str, str]
             * @example {
             *       "de": "Erhalte 20% Rabatt",
             *       "en": "Get 20% off",
             *       "nl": "Krijg 20% korting"
             *     }
             */
            title: {
                [key: string]: string;
            };
            /**
             * Description
             * @description Localized offer description. Object with language codes as keys (e.g., 'en', 'de', 'nl') and translated text as values. Type: dict[str, str]
             * @example {
             *       "de": "Wir gewhren dir einen Rabatt",
             *       "en": "We'll apply a discount to your subscription",
             *       "nl": "We geven je korting"
             *     }
             */
            description?: {
                [key: string]: string;
            } | null;
            /** Conditions */
            conditions?: (components["schemas"]["LifetimeOrdersCondition"] | components["schemas"]["LifetimeSpentCondition"] | components["schemas"]["CustomerMetafieldCondition"] | components["schemas"]["ActiveContractCountCondition"] | components["schemas"]["ActiveProductCountCondition"])[] | null;
            /**
             * Cooldown Days
             * @description Number of days before customer can accept this offer again. If null, offer can be accepted multiple times without restriction.
             */
            cooldown_days?: number | null;
            /**
             * Active
             * @description Whether this offer is active and should be shown to customers. Defaults to True for backward compatibility.
             * @default true
             */
            active: boolean;
        };
        /**
         * SetNextDeliveryDateAction
         * @description Set the next delivery date.
         *
         *     Allows customer to reschedule their next delivery to a specific date,
         *     providing flexibility for timing control.
         *
         *     ### Configuration Parameters
         *
         *     No configuration needed - customer provides desired date in accept request.
         *
         *     ### Customer Request Required
         *
         *     Customer must provide `next_delivery_date` (ISO 8601 format) when accepting.
         *
         *     ### Example Use Cases
         *
         *     - Vacation scheduling: Delay delivery until customer returns
         *     - Event timing: Ensure delivery arrives before specific date
         *     - Inventory management: Customer wants to receive order at specific time
         *     - Gift timing: Coordinate delivery with gift-giving occasion
         */
        SetNextDeliveryDateAction: {
            /**
             * Type
             * @constant
             */
            type: "set_next_delivery_date";
        };
        /**
         * SkipNextDeliveryAction
         * @description Skip the next delivery for a subscription.
         *
         *     Moves the next billing date forward by one billing cycle interval.
         *     Useful when customers need a pause but don't want to pause the entire subscription.
         *
         *     ### Configuration
         *
         *     No additional parameters required - the skip duration is calculated automatically
         *     based on the subscription's current billing interval.
         *
         *     ### Example Use Cases
         *
         *     - Customer is traveling and won't be home for next delivery
         *     - Customer has excess inventory and needs to delay next shipment
         *     - Temporary financial constraints
         */
        SkipNextDeliveryAction: {
            /**
             * Type
             * @constant
             */
            type: "skip_next_delivery";
        };
        /**
         * StorefrontAddLineItemRequest
         * @description Request model for adding a product to a subscription from storefront.
         */
        StorefrontAddLineItemRequest: {
            /**
             * Subscription Id
             * @description The id of the subscription to modify. Fully qualified shopify gid (gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            /** @description Line item details */
            line_item: components["schemas"]["BaseSubscriptionLineInput"];
        };
        /**
         * StorefrontCancelRequest
         * @description Request model for cancelling a subscription from storefront.
         */
        StorefrontCancelRequest: {
            /**
             * Move One Times To Next Eligible Date
             * @description Whether to move one times to the next eligible delivery for the customer or not. For merchants that only allow one subscription per customer this should always be set to False
             * @default true
             */
            move_one_times_to_next_eligible_date: boolean;
            /**
             * Subscription Id
             * @description The id of the subscription to cancel. This is in Shopify format, e.g. gid://shopify/SubscriptionContract/123456
             */
            subscription_id: string;
            /**
             * Reason
             * @description The reason for cancelling
             */
            reason: string;
            /**
             * Other Cancellation Reason
             * @description Additional details about the cancellation reason
             */
            other_cancellation_reason?: string | null;
            /**
             * Permanent
             * @description If True, permanently cancels in Shopify (status=CANCELLED). This action cannot be undone - the subscription cannot be reactivated. If False (default), pauses (status=PAUSED), allowing reactivation later.
             * @default false
             */
            permanent: boolean;
            /**
             * Reason Id
             * @description Optional cancellation reason ID from GET /churn-prevention/cancellation-reasons endpoint. When provided, this cancel is treated as part of the churn prevention flow and will log CHURN_PREVENTION/CANCELLATION_COMPLETED activity instead of UPDATE_SUBSCRIPTION_CONTRACT/PAUSE
             */
            reason_id?: string | null;
        };
        /**
         * StorefrontChangeProductQuantityRequest
         * @description Request model for changing a product of a subscription from storefront. Either quantity or variant_id mus be provided.
         */
        StorefrontChangeProductQuantityRequest: {
            /**
             * Subscription Id
             * @description The id of the subscription to pause. Fully qualified shopify gid (e.g. gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            /**
             * Line Item Id
             * @description The line item to change. This is fully qualified shopify gid (e.g. gid://shopify/SubscriptionLine/XXX)
             */
            line_item_id: string;
            /**
             * Quantity
             * @description The new quantity for the line.
             */
            quantity: number;
        };
        /**
         * StorefrontChangeProductVariantRequest
         * @description Request model for changing a product of a subscription from storefront. Either quantity or variant_id mus be provided.
         */
        StorefrontChangeProductVariantRequest: {
            /**
             * Subscription Id
             * @description The id of the subscription to pause. Fully qualified shopify gid (e.g. gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            /**
             * Line Item Id
             * @description The line item to change. This is fully qualified shopify gid (e.g. gid://shopify/SubscriptionLine/XXX)
             */
            line_item_id: string;
            /**
             * Variant Id
             * @description The new variant id for the line. This is fully qualified shopify gid (e.g. gid://shopify/ProductVariant/XXX)
             */
            variant_id: string;
            /**
             * Selling Plan Id
             * @description The selling plan id of the new line item if the variant changes. If missing the price will default to first selling plan.
             */
            selling_plan_id?: string | null;
        };
        /**
         * StorefrontCreateSubscriptionRequest
         * @description Storefront API request model for creating subscription contracts.
         *
         *     Customer ID and store are derived from the JWT token.
         *     Price overrides are not allowed - prices are always fetched from Shopify.
         *     Delivery price and currency are determined server-side based on store config.
         */
        StorefrontCreateSubscriptionRequest: {
            /**
             * Next Billing Date
             * @description Next billing date in YYYY-MM-DD format
             */
            next_billing_date: string;
            /**
             * Interval
             * @description Billing interval (DAY, WEEK, MONTH, YEAR)
             * @default WEEK
             * @enum {string}
             */
            interval: "DAY" | "WEEK" | "MONTH" | "YEAR";
            /**
             * Interval Count
             * @description Number of intervals between billings
             * @default 1
             */
            interval_count: number;
            /**
             * Payment Method Id
             * @description Shopify customer payment method ID
             */
            payment_method_id: string;
            /** @description Delivery address for the subscription */
            delivery_address: components["schemas"]["Address"];
            /**
             * Delivery Method Type
             * @description Whether to use local delivery or shipping as a delivery method
             * @default shipping
             * @enum {string}
             */
            delivery_method_type: "shipping" | "local_delivery";
            /**
             * Discount Codes
             * @description Discount codes to apply
             */
            discount_codes?: string[] | null;
            /**
             * Custom Attributes
             * @description Custom attributes for the contract
             */
            custom_attributes?: components["schemas"]["CustomAttribute"][] | null;
            /**
             * Lines
             * @description Line items for the subscription (prices will be fetched from Shopify)
             */
            lines: components["schemas"]["BaseSubscriptionLineInput"][];
        };
        /**
         * StorefrontLineItemCancelRequest
         * @description Request model for cancelling a line item from storefront.
         */
        StorefrontLineItemCancelRequest: {
            /**
             * Move One Times To Next Eligible Date
             * @description Whether to move one times to the next eligible delivery for the customer or not. For merchants that only allow one subscription per customer this should always be set to False
             * @default true
             */
            move_one_times_to_next_eligible_date: boolean;
            /**
             * Return Base Subscription When Splitting
             * @description If `True`, forces the response model to be `SubscriptionWithOriginalResponse`. If the pause operation required splitting the subscription, `subscription` will contain the newly created contract and `original_subscription` will contain the original contract (with the line item removed). If no split occurred, `original_subscription` will be `None`.
             * @default false
             */
            return_base_subscription_when_splitting: boolean;
            /**
             * Subscription Id
             * @description The id of the subscription to cancel. This is in Shopify format, e.g. gid://shopify/SubscriptionContract/123456
             */
            subscription_id: string;
            /**
             * Reason
             * @description The reason for cancelling
             */
            reason: string;
            /**
             * Other Cancellation Reason
             * @description Additional details about the cancellation reason
             */
            other_cancellation_reason?: string | null;
            /**
             * Permanent
             * @description If True, permanently cancels in Shopify (status=CANCELLED). This action cannot be undone - the subscription cannot be reactivated. If False (default), pauses (status=PAUSED), allowing reactivation later.
             * @default false
             */
            permanent: boolean;
            /**
             * Line Item Id
             * @description The id of the line item to cancel. This is in Shopify format, e.g. gid://shopify/SubscriptionLine/789012
             */
            line_item_id: string;
            /**
             * Reason Id
             * @description Optional cancellation reason ID from GET /churn-prevention/cancellation-reasons endpoint. When provided, this cancel is treated as part of the churn prevention flow and will log CHURN_PREVENTION/CANCELLATION_COMPLETED activity instead of UPDATE_SUBSCRIPTION_CONTRACT/PAUSE
             */
            reason_id?: string | null;
        };
        /**
         * StorefrontMultiUpdateRequest
         * @description Request to perform multiple subscription modifications in one operation.
         */
        StorefrontMultiUpdateRequest: {
            /**
             * Subscription Id
             * @description The subscription contract ID to modify (format: gid://shopify/SubscriptionContract/123456789)
             */
            subscription_id: string;
            /**
             * Lines To Add
             * @description Products to add to the subscription
             */
            lines_to_add?: components["schemas"]["BaseSubscriptionLineInput"][] | null;
            /**
             * Lines To Remove
             * @description Line item IDs to remove (format: gid://shopify/SubscriptionLine/uuid, e.g., 'gid://shopify/SubscriptionLine/30bf89d8-9309-4477-98e5-2ea1e35d44a7')
             */
            lines_to_remove?: string[] | null;
            /**
             * Lines To Update
             * @description Line items to update (quantity, variant, or selling plan)
             */
            lines_to_update?: components["schemas"]["LineUpdateInput"][] | null;
            /**
             * Discount Codes To Apply
             * @description Discount codes to apply (format: plain code strings like 'SUMMER10' or 'WELCOME20')
             */
            discount_codes_to_apply?: string[] | null;
            /**
             * Discount Codes To Remove
             * @description Discount IDs to remove (format: gid://shopify/SubscriptionManualDiscount/uuid, e.g., 'gid://shopify/SubscriptionManualDiscount/a966faac-83bc-4ab1-ab98-fd2b289f14c0')
             */
            discount_codes_to_remove?: string[] | null;
        };
        /**
         * StorefrontReactivateRequest
         * @description Request model for reactivating a line item from storefront.
         */
        StorefrontReactivateRequest: {
            /**
             * Return Base Subscription When Splitting
             * @description If `True`, forces the response model to be `SubscriptionWithOriginalResponse`. If the pause operation required splitting the subscription, `subscription` will contain the newly created contract and `original_subscription` will contain the original contract (with the line item removed). If no split occurred, `original_subscription` will be `None`.
             * @default false
             */
            return_base_subscription_when_splitting: boolean;
            /**
             * Subscription Id
             * @description The id of the subscription to reactivate. Fully qualified shopify gid (gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            /**
             * Line Item Id
             * @description The line item to reactivate. Provide a fully qualified shopify gid (gid://shopify/SubscriptionLine/XXX)
             */
            line_item_id: string;
        };
        /**
         * StorefrontRemoveLineItemRequest
         * @description Request model for adding a product to a subscription from storefront.
         */
        StorefrontRemoveLineItemRequest: {
            /**
             * Subscription Id
             * @description The id of the subscription to modify. Fully qualified shopify gid (gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            /**
             * Line Item Id
             * @description Line item ID to remove. If the contract is a single item contract it will be cancelled.
             */
            line_item_id: string;
        };
        /**
         * StorefrontSetDeliveryAddressRequest
         * @description Request model for changing the delivery address subscription from storefront.
         */
        StorefrontSetDeliveryAddressRequest: {
            /**
             * Return Base Subscription When Splitting
             * @description If `True`, forces the response model to be `SubscriptionWithOriginalResponse`. If the pause operation required splitting the subscription, `subscription` will contain the newly created contract and `original_subscription` will contain the original contract (with the line item removed). If no split occurred, `original_subscription` will be `None`.
             * @default false
             */
            return_base_subscription_when_splitting: boolean;
            /**
             * Subscription Id
             * @description The id of the subscription to modify. Fully qualified shopify gid (gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            /**
             * Line Item Id
             * @description The line item to change the address for. If not provided, pauses the entire contract. Provide a fully qualified shopify gid (gid://shopify/SubscriptionLine/XXX)
             */
            line_item_id?: string | null;
            address: components["schemas"]["Address"];
        };
        /**
         * StorefrontSetDeliveryIntervalRequest
         * @description Request model for changing the delivery interval subscription from storefront.
         */
        StorefrontSetDeliveryIntervalRequest: {
            /**
             * Return Base Subscription When Splitting
             * @description If `True`, forces the response model to be `SubscriptionWithOriginalResponse`. If the pause operation required splitting the subscription, `subscription` will contain the newly created contract and `original_subscription` will contain the original contract (with the line item removed). If no split occurred, `original_subscription` will be `None`.
             * @default false
             */
            return_base_subscription_when_splitting: boolean;
            /**
             * Subscription Id
             * @description The id of the subscription to modify. Fully qualified shopify gid (gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            /**
             * Line Item Id
             * @description The line item to change the address for.Provide a fully qualified shopify gid (gid://shopify/SubscriptionLine/XXX)
             */
            line_item_id: string;
            /**
             * Interval Count
             * @description The number of intervals with associated unit between orders.
             */
            interval_count: number;
            /**
             * Interval Unit
             * @description Unit of interval that's associated with this schedule. Allowed values are: DAY, WEEK, MONTH and YEAR
             */
            interval_unit: string;
        };
        /**
         * StorefrontSetNextBillingDateRequest
         * @description Request model for changing a next billing date of a subscription from storefront.
         */
        StorefrontSetNextBillingDateRequest: {
            /**
             * Subscription Id
             * @description The id of the subscription to pause. Fully qualified shopify gid (gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            /**
             * Next Billing Date
             * Format: date-time
             * @description The desired next billing date for the subscription. Accepts date (YYYY-MM-DD) or datetime (ISO 8601) format. Time component is ignored.
             * @example 2025-12-11
             * @example 2025-12-11T00:00:00Z
             */
            next_billing_date: string;
            /**
             * Move One Times To Next Eligible Date
             * @description Whether to move one times to the next eligible delivery for the customer or not. For merchants that only allow one subscription per customer this should always be set to False
             * @default true
             */
            move_one_times_to_next_eligible_date: boolean;
        };
        /**
         * StorefrontShipTomorrowRequest
         * @description Request model for moving an order for a subscription to tomorrow from storefront.
         */
        StorefrontShipTomorrowRequest: {
            /**
             * Subscription Id
             * @description The id of the subscription to ship_order_tomorrow. Fully qualified shopify gid (gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            /**
             * Move One Times To Next Eligible Date
             * @description Whether to move one times to the next eligible delivery for the customer or not. For merchants that only allow one subscription per customer this should always be set to False
             * @default true
             */
            move_one_times_to_next_eligible_date: boolean;
        };
        /**
         * StorefrontSkipNextDeliveryRequest
         * @description Request model for skipping the next delivery of a subscription from storefront.
         */
        StorefrontSkipNextDeliveryRequest: {
            /**
             * Subscription Id
             * @description The id of the subscription to modify. Fully qualified shopify gid (gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            /**
             * Move One Times To Next Eligible Date
             * @description Whether to move one times to the next eligible delivery for the customer or not. For merchants that only allow one subscription per customer this should always be set to False
             * @default true
             */
            move_one_times_to_next_eligible_date: boolean;
        };
        /**
         * StorefrontUnskipNextDeliveryRequest
         * @description Request model for unskipping the next delivery of a subscription from storefront.
         */
        StorefrontUnskipNextDeliveryRequest: {
            /**
             * Subscription Id
             * @description The id of the subscription to modify. Fully qualified shopify gid (gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            /**
             * Move One Times To Next Eligible Date
             * @description Whether to move one times to the next eligible delivery for the customer or not. For merchants that only allow one subscription per customer this should always be set to False
             * @default true
             */
            move_one_times_to_next_eligible_date: boolean;
        };
        /**
         * SubscriptionContractFull
         * @description Full subscription contract with all fields.
         */
        SubscriptionContractFull: {
            /**
             * Id
             * @description the shopify GID of the contract.
             */
            id: string;
            /**
             * Next Billing Date
             * Format: date-time
             * @description the date where the contract is next to be billed
             */
            next_billing_date: string;
            /** @description Billing policy of the contract */
            billing_policy: components["schemas"]["BillingPolicy"] | null;
            /** @description customer data */
            customer: components["schemas"]["Customer"];
            /**
             * Lines
             * @description The lines of the contract (the first one is the original contract item. the following ones are either concatenated items or one time add ons
             */
            lines: components["schemas"]["ContractLine"][];
            /** @description Payment method of the customer */
            customer_payment_method?: components["schemas"]["CustomerPaymentMethod"] | null;
            /** @description Delivery policy of the contract */
            delivery_policy: components["schemas"]["DeliveryPolicy"];
            /**
             * Custom Attributes
             * @description Custom attributes of the contract
             */
            custom_attributes?: components["schemas"]["CustomAttribute"][] | null;
            /** @description Delivery method of the contract */
            delivery_method: components["schemas"]["DeliveryMethod"];
            /** @description The delivery price for each billing of the subscription contract. */
            delivery_price: components["schemas"]["Price"] | null;
            /**
             * Discounts
             * @description List of discounts on the contract. If they have a rejection reason will no longer be applied
             * @default []
             */
            discounts: components["schemas"]["ContractDiscounts"][] | null;
            /**
             * Revision Id
             * @description Revision id indicates a version of the contract, it's increasing but not necessarily every number is being used
             */
            revision_id: number;
            /**
             * Updated At
             * Format: date-time
             * @description The datetime, when the contract was last updated
             */
            updated_at: string;
            /**
             * Created At
             * Format: date-time
             * @description The datetime, when the contract was created
             */
            created_at: string;
            /**
             * Origin Order Id
             * @description The original checkout order that the contract has been created through. This is only correct for the contracts that have been created through eversubs.
             */
            origin_order_id?: string | null;
            /**
             * Status
             * @description The status of the contract.
             */
            status?: ("ACTIVE" | "CANCELLED" | "EXPIRED" | "FAILED" | "PAUSED" | "STALE") | null;
        };
        /**
         * SubscriptionResponse
         * @description Response model for subscription operations.
         */
        SubscriptionResponse: {
            subscription: components["schemas"]["SubscriptionContractFull"];
        };
        /**
         * SubscriptionWithOriginalResponse
         * @description Response model for subscription operations that require splitting.
         */
        SubscriptionWithOriginalResponse: {
            subscription: components["schemas"]["SubscriptionContractFull"];
            original_subscription: components["schemas"]["SubscriptionContractFull"] | null;
        };
        /**
         * SubscriptionsResponse
         * @description Response model for subscription queries with pagination support.
         */
        SubscriptionsResponse: {
            /** Subscriptions */
            subscriptions: components["schemas"]["SubscriptionContractFull"][];
            /**
             * Next Cursor
             * @description Cursor for pagination - pass this value to get the next page of results
             */
            next_cursor?: string | null;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /**
         * StorefrontSetNextBillingDateRequest
         * @description Request model for changing a next billing date of a subscription from storefront.
         */
        app__api__storefront__v1__line_items__set_next_billing_date__StorefrontSetNextBillingDateRequest: {
            /**
             * Move One Times To Next Eligible Date
             * @description Whether to move one times to the next eligible delivery for the customer or not. For merchants that only allow one subscription per customer this should always be set to False
             * @default true
             */
            move_one_times_to_next_eligible_date: boolean;
            /**
             * Return Base Subscription When Splitting
             * @description If `True`, forces the response model to be `SubscriptionWithOriginalResponse`. If the pause operation required splitting the subscription, `subscription` will contain the newly created contract and `original_subscription` will contain the original contract (with the line item removed). If no split occurred, `original_subscription` will be `None`.
             * @default false
             */
            return_base_subscription_when_splitting: boolean;
            /**
             * Subscription Id
             * @description The id of the subscription to pause. Fully qualified shopify gid (gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            /**
             * Line Item Id
             * @description The line item to change next billing date. Provide a fully qualified shopify gid (gid://shopify/SubscriptionLine/XXX)
             */
            line_item_id: string;
            /**
             * Next Billing Date
             * Format: date-time
             * @description The desired next billing date for the subscription. Accepts date (YYYY-MM-DD) or datetime (ISO 8601) format. Time component is ignored.
             * @example 2025-12-11
             * @example 2025-12-11T00:00:00Z
             */
            next_billing_date: string;
        };
        /**
         * StorefrontShipTomorrowRequest
         * @description Request model for moving an order for a subscription to tomorrow from storefront.
         */
        app__api__storefront__v1__line_items__ship_order_tomorrow__StorefrontShipTomorrowRequest: {
            /**
             * Move One Times To Next Eligible Date
             * @description Whether to move one times to the next eligible delivery for the customer or not. For merchants that only allow one subscription per customer this should always be set to False
             * @default true
             */
            move_one_times_to_next_eligible_date: boolean;
            /**
             * Return Base Subscription When Splitting
             * @description If `True`, forces the response model to be `SubscriptionWithOriginalResponse`. If the pause operation required splitting the subscription, `subscription` will contain the newly created contract and `original_subscription` will contain the original contract (with the line item removed). If no split occurred, `original_subscription` will be `None`.
             * @default false
             */
            return_base_subscription_when_splitting: boolean;
            /**
             * Subscription Id
             * @description The id of the subscription to ship_order_tomorrow. Fully qualified shopify gid (gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            /**
             * Line Item Id
             * @description The line item to ship tomorrow next.Provide a fully qualified shopify gid (gid://shopify/SubscriptionLine/XXX)
             */
            line_item_id: string;
        };
        /**
         * StorefrontSkipNextDeliveryRequest
         * @description Request model for skipping the next delivery of a subscription from storefront.
         */
        app__api__storefront__v1__line_items__skip_next_delivery__StorefrontSkipNextDeliveryRequest: {
            /**
             * Move One Times To Next Eligible Date
             * @description Whether to move one times to the next eligible delivery for the customer or not. For merchants that only allow one subscription per customer this should always be set to False
             * @default true
             */
            move_one_times_to_next_eligible_date: boolean;
            /**
             * Return Base Subscription When Splitting
             * @description If `True`, forces the response model to be `SubscriptionWithOriginalResponse`. If the pause operation required splitting the subscription, `subscription` will contain the newly created contract and `original_subscription` will contain the original contract (with the line item removed). If no split occurred, `original_subscription` will be `None`.
             * @default false
             */
            return_base_subscription_when_splitting: boolean;
            /**
             * Subscription Id
             * @description The id of the subscription to modify. Fully qualified shopify gid (gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            /**
             * Line Item Id
             * @description The line item to skip the next delivery.Provide a fully qualified shopify gid (gid://shopify/SubscriptionLine/XXX)
             */
            line_item_id: string | null;
        };
        /**
         * StorefrontUnskipNextDeliveryRequest
         * @description Request model for skipping the next delivery of a subscription from storefront.
         */
        app__api__storefront__v1__line_items__unskip_next_delivery__StorefrontUnskipNextDeliveryRequest: {
            /**
             * Move One Times To Next Eligible Date
             * @description Whether to move one times to the next eligible delivery for the customer or not. For merchants that only allow one subscription per customer this should always be set to False
             * @default true
             */
            move_one_times_to_next_eligible_date: boolean;
            /**
             * Return Base Subscription When Splitting
             * @description If `True`, forces the response model to be `SubscriptionWithOriginalResponse`. If the pause operation required splitting the subscription, `subscription` will contain the newly created contract and `original_subscription` will contain the original contract (with the line item removed). If no split occurred, `original_subscription` will be `None`.
             * @default false
             */
            return_base_subscription_when_splitting: boolean;
            /**
             * Subscription Id
             * @description The id of the subscription to modify. Fully qualified shopify gid (gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            /**
             * Line Item Id
             * @description The line item to unskip the next delivery.Provide a fully qualified shopify gid (gid://shopify/SubscriptionLine/XXX)
             */
            line_item_id: string | null;
        };
        /**
         * StorefrontReactivateRequest
         * @description Request model for reactivating a subscription from storefront.
         */
        app__api__storefront__v1__subscriptions__reactivate__StorefrontReactivateRequest: {
            /**
             * Subscription Id
             * @description The id of the subscription to reactivate. Fully qualified shopify gid (gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
        };
        /**
         * StorefrontSetDeliveryAddressRequest
         * @description Request model for changing the delivery address subscription from storefront.
         */
        app__api__storefront__v1__subscriptions__set_delivery_address__StorefrontSetDeliveryAddressRequest: {
            /**
             * Subscription Id
             * @description The id of the subscription to modify. Fully qualified shopify gid (gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            address: components["schemas"]["Address"];
        };
        /**
         * StorefrontSetDeliveryIntervalRequest
         * @description Request model for changing the delivery interval subscription from storefront.
         */
        app__api__storefront__v1__subscriptions__set_delivery_interval__StorefrontSetDeliveryIntervalRequest: {
            /**
             * Subscription Id
             * @description The id of the subscription to modify. Fully qualified shopify gid (gid://shopify/SubscriptionContract/XXX)
             */
            subscription_id: string;
            /**
             * Interval Count
             * @description The number of intervals with associated unit between orders.
             */
            interval_count: number;
            /**
             * Interval Unit
             * @description Unit of interval that's associated with this schedule. Allowed values are: DAY, WEEK, MONTH and YEAR
             */
            interval_unit: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    retrieve_subscription_v1_subscriptions_get: {
        parameters: {
            query?: {
                /** @description Maximum number of results to retrieve */
                limit?: number;
                /** @description Pagination cursor from previous response */
                cursor?: string | null;
                /** @description Shopify subscription contract ID for direct retrieval (e.g., 'gid://shopify/SubscriptionContract/123') */
                subscription_id?: string | null;
                /** @description Contract status filter. Single status or list of status from the following options 'ACTIVE', 'CANCELLED', 'EXPIRED', 'FAILED', 'PAUSED', 'STALE' */
                status?: ("ACTIVE" | "CANCELLED" | "EXPIRED" | "FAILED" | "PAUSED" | "STALE")[] | ("ACTIVE" | "CANCELLED" | "EXPIRED" | "FAILED" | "PAUSED" | "STALE") | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cancel_subscription_v1_subscriptions_cancel_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StorefrontCancelRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    reactivate_subscription_v1_subscriptions_reactivate_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["app__api__storefront__v1__subscriptions__reactivate__StorefrontReactivateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    set_next_billing_date_v1_subscriptions_set_next_billing_date_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StorefrontSetNextBillingDateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    skip_next_delivery_v1_subscriptions_skip_next_delivery_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StorefrontSkipNextDeliveryRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    unskip_next_delivery_v1_subscriptions_unskip_next_delivery_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StorefrontUnskipNextDeliveryRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    ship_order_tomorrow_v1_subscriptions_ship_order_tomorrow_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StorefrontShipTomorrowRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    charge_now_v1_subscriptions_charge_now_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BaseChargeNowRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ChargeNowResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    set_delivery_address_v1_subscriptions_set_delivery_address_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["app__api__storefront__v1__subscriptions__set_delivery_address__StorefrontSetDeliveryAddressRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    set_delivery_interval_v1_subscriptions_set_delivery_interval_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["app__api__storefront__v1__subscriptions__set_delivery_interval__StorefrontSetDeliveryIntervalRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    change_payment_method_endpoint_v1_subscriptions_change_payment_method_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChangePaymentMethodRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    request_payment_update_email_v1_subscriptions_request_payment_update_email_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RequestPaymentUpdateEmailRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RequestPaymentUpdateEmailResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    multi_update_subscription_v1_subscriptions_multi_update_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StorefrontMultiUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    create_subscription_v1_subscriptions_create_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StorefrontCreateSubscriptionRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    cancel_line_item_v1_line_items_cancel_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StorefrontLineItemCancelRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    /** @description Fresh JWT token with updated subscription IDs (only present when subscription was split) */
                    "X-Storefront-Token-Refresh"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"] | components["schemas"]["SubscriptionWithOriginalResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    reactivate_subscription_v1_line_items_reactivate_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StorefrontReactivateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    /** @description Fresh JWT token with updated subscription IDs (only present when subscription was split) */
                    "X-Storefront-Token-Refresh"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"] | components["schemas"]["SubscriptionWithOriginalResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    set_next_billing_date_v1_line_items_set_next_billing_date_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["app__api__storefront__v1__line_items__set_next_billing_date__StorefrontSetNextBillingDateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    /** @description Fresh JWT token with updated subscription IDs (only present when subscription was split) */
                    "X-Storefront-Token-Refresh"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"] | components["schemas"]["SubscriptionWithOriginalResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    skip_next_delivery_v1_line_items_skip_next_delivery_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["app__api__storefront__v1__line_items__skip_next_delivery__StorefrontSkipNextDeliveryRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    /** @description Fresh JWT token with updated subscription IDs (only present when subscription was split) */
                    "X-Storefront-Token-Refresh"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"] | components["schemas"]["SubscriptionWithOriginalResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    unskip_next_delivery_v1_line_items_unskip_next_delivery_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["app__api__storefront__v1__line_items__unskip_next_delivery__StorefrontUnskipNextDeliveryRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    /** @description Fresh JWT token with updated subscription IDs (only present when subscription was split) */
                    "X-Storefront-Token-Refresh"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"] | components["schemas"]["SubscriptionWithOriginalResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    ship_order_tomorrow_v1_line_items_ship_order_tomorrow_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["app__api__storefront__v1__line_items__ship_order_tomorrow__StorefrontShipTomorrowRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    /** @description Fresh JWT token with updated subscription IDs (only present when subscription was split) */
                    "X-Storefront-Token-Refresh"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"] | components["schemas"]["SubscriptionWithOriginalResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    change_product_quantity_v1_line_items_change_product_quantity_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StorefrontChangeProductQuantityRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    change_product_variant_v1_line_items_change_product_variant_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StorefrontChangeProductVariantRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    set_delivery_address_v1_line_items_set_delivery_address_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StorefrontSetDeliveryAddressRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    /** @description Fresh JWT token with updated subscription IDs (only present when subscription was split) */
                    "X-Storefront-Token-Refresh"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"] | components["schemas"]["SubscriptionWithOriginalResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    set_delivery_interval_v1_line_items_set_delivery_interval_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StorefrontSetDeliveryIntervalRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    /** @description Fresh JWT token with updated subscription IDs (only present when subscription was split) */
                    "X-Storefront-Token-Refresh"?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"] | components["schemas"]["SubscriptionWithOriginalResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    add_line_item_v1_line_items_add_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StorefrontAddLineItemRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    remove_line_item_v1_line_items_remove_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StorefrontRemoveLineItemRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SubscriptionResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_location_v1_delivery_dates_location_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LocationRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LocationResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    calendar_v1_delivery_dates_calendar_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CalendarRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EligibleDatesCalendar"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_payment_methods_v1_customers_payment_methods_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PaymentMethodsResponse"];
                };
            };
        };
    };
    get_cancellation_reasons_v1_churn_prevention_cancellation_reasons_get: {
        parameters: {
            query: {
                /** @description Subscription ID to check cancellation reasons for */
                subscription_id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetCancellationReasonsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_cancellation_reason_offers_v1_churn_prevention_offers_get: {
        parameters: {
            query: {
                /** @description Subscription ID to get offers for */
                subscription_id: string;
                /** @description Cancellation reason ID to get offers for */
                reason_id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetCancellationReasonOffersResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    accept_retention_offer_v1_churn_prevention_accept_offer_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AcceptRetentionOfferRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AcceptRetentionOfferResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
}
