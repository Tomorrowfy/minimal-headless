/* eslint-disable @typescript-eslint/no-explicit-any */
//
// Generated by the assistant from the provided OpenAPI schema
//

/**
 * Name of the app involved in the log entry, useful for debugging and development. Can also include versions.
 */
export type SubscriptionAppName = string | null;

/**
 * Shopify store name.
 */
export type Store = string;

/**
 * Email of the creator or string indicating of the process that issued the changes
 */
export type CausedBy = string;

/**
 * The datetime (in UTC) when the activity took place.
 */
export type Timestamp = string;

/**
 * Group ID if multiple log should be grouped together.
 */
export type TransactionGroupId = string | null;

/**
 * The type of activity
 */
export type ActivityType =
  | "CHANGE_APP_SETTINGS"
  | "CREATE_ORDER"
  | "CREATE_PAYMENT_METHOD"
  | "CREATE_SELLING_PLAN_GROUP"
  | "CREATE_SUBSCRIPTION_CONTRACT"
  | "CUSTOMER_REDACTION"
  | "DELETE_PAYMENT_METHOD"
  | "DELETE_SELLING_PLAN_GROUP"
  | "FAILED_BILLING_ATTEMPT"
  | "INVENTORY_ISSUE"
  | "SENT_CUSTOMER_NOTIFICATION"
  | "SENT_PAYMENT_METHOD_UPDATE_EMAIL"
  | "SKIP_CHARGE_ATTEMPT"
  | "SUCCESSFUL_BILLING_ATTEMPT"
  | "SYSTEM_MESSAGE"
  | "UPDATE_CUSTOMER"
  | "UPDATE_PAYMENT_METHOD"
  | "UPDATE_SELLING_PLAN_GROUP"
  | "UPDATE_SUBSCRIPTION_CONTRACT"
  | "BILLING_ATTEMPT"
  | "CONCATENATE_CHARGES"
  | "DELETE_BILLING_CYCLE_EDITS"
  | "REMOVE_LINE_FROM_CONTRACT"
  | "SEND_CUSTOMER_NOTIFICATION"
  | "UPDATE_SHIPPING_ADDRESS";

/**
 * The subtype of the activity
 */
export type ActivitySubtype =
  | "ADD_DISCOUNT"
  | "ADD_ONETIME_PRODUCT"
  | "ADD_PRODUCT"
  | "ADD_PRODUCT_VARIANT"
  | "APPLY_DISCOUNT_CODE"
  | "CANCEL"
  | "CONCATENATE_CHARGES"
  | "CREATE"
  | "CREATE_MERCHANT_API_TOKEN"
  | "DELETE_MERCHANT_API_TOKEN"
  | "CREATE_SELLING_PLAN"
  | "DELETE_BILLING_CYCLE_EDITS"
  | "DELETE_SELLING_PLAN"
  | "DELIVERY_OPTIMIZATION"
  | "ERROR"
  | "PAUSE"
  | "SPLIT"
  | "RECEIVED_REDACTION_REQUEST"
  | "REDACTED_LOGS"
  | "REDACTED_SUBSCRIPTION_DATABASE"
  | "REMOVE_DEPOSIT_PRODUCT"
  | "REMOVE_DISCOUNT_CODE"
  | "REMOVE_ONETIME_PRODUCT"
  | "REMOVE_PRODUCT"
  | "REMOVE_PRODUCT_VARIANT"
  | "RESUME"
  | "SET_BUNDLE_STATE_ATTRIBUTE"
  | "SET_CUSTOMER_PORTAL_METAFIELD"
  | "SET_DELIVERY_METHOD"
  | "SUCCESS"
  | "UPCOMING_DELIVERY"
  | "UPDATE_BILLING_POLICY"
  | "UPDATE_DELIVERY_DATE"
  | "UPDATE_DELIVERY_POLICY"
  | "UPDATE_DELIVERY_PRICE"
  | "UPDATE_DISCOUNT_CODE"
  | "UPDATE_FAILED_PAYMENT_SETTINGS"
  | "UPDATE_NEXT_BILLING_DATE"
  | "UPDATE_NOTIFICATIONS_METAFIELD"
  | "UPDATE_NOTIFICATION_SETTINGS"
  | "UPDATE_PAYMENT_METHOD"
  | "UPDATE_PROCESSING_SETTINGS"
  | "UPDATE_PRODUCT"
  | "UPDATE_PRODUCT_PRICE"
  | "UPDATE_PRODUCT_QUANTITY"
  | "UPDATE_SELLING_PLAN"
  | "UPDATE_SHIPPING_ADDRESS"
  | "VARIANT_ARCHIVED"
  | "VARIANT_OUT_OF_STOCK"
  | "UPDATE_SELLINGPLAN"
  | "CREATE_SELLINGPLAN"
  | "DELETE_SELLINGPLAN"
  | "UPDATE_PRODUCT_VARIANT"
  | "";

/**
 * Shopify customer ID.
 */
export type RelatedToCustomer = string | null;

/**
 * Shopify Subscription contract ID.
 */
export type RelatedToSubscription = string | null;

/**
 * The log message.
 */
export type Message = string;

/**
 * Log level and severity of the log, the following levels are valid "DEBUG", "INFO", "WARNING", "ERROR" , "EMERGENCY"
 */
export type LogLevel = "DEBUG" | "INFO" | "WARNING" | "ERROR" | "EMERGENCY";

/**
 * Additional structured data for the activity type, typically used to get information in a structured way
 */
export type Details = Record<string, any> | null;

/**
 * First line of the address
 */
export type Address1 = string | null;

/**
 * Second line of the address
 */
export type Address2 = string | null;

/**
 * ZIP code
 */
export type Zip = string | null;

/**
 * City
 */
export type City = string | null;

/**
 * Company name
 */
export type Company = string | null;

/**
 * Country
 */
export type Country = string | null;

/**
 * Country code
 */
export type CountryCode = string | null;

/**
 * Province code. For some countries this is mandatory when creating a contract
 */
export type ProvinceCode = string | null;

/**
 * First name
 */
export type FirstName = string | null;

/**
 * Last name
 */
export type LastName = string | null;

/**
 * Full name
 */
export type Name = string | null;

/**
 * Percentage or fixed value of the discount.
 */
export type Value = number;

/**
 * PERCENTAGE or FIXED
 */
export type DiscountType = "PERCENTAGE" | "FIXED";

/**
 * If the discount is limited to a set amount of applications.
 */
export type RecurringCycleLimit = number | null;

/**
 * title of the discount to be created
 */
export type Title = string | null;

/**
 * lines that the discount should be applied to. defaults to all. Otherwise comma seperated list of lines to apply the discount to
 */
export type EntitledLines = string;

/**
 * The Shopify store identifier (without .myshopify.com) - if not provided, will be extracted from token
 */
export type Store1 = string | null;

/**
 * The subscription ID
 */
export type SubscriptionId = string;

/**
 * Shopify customer ID for validation
 */
export type CustomerId = string;

/**
 * Email of customer or name of process that triggers the change.
 */
export type CausedBy1 = string;

/**
 * Customer email for logging purposes
 */
export type CustomerEmail = string;

/**
 * Shopify product ID
 */
export type ProductId = string;

/**
 * The Shopify GID of the billing attempt
 */
export type Id = string;

/**
 * When the billing attempt was created
 */
export type CreatedAt = string;

/**
 * When the billing attempt was completed
 */
export type CompletedAt = string | null;

/**
 * Unique key to avoid duplicate payments
 */
export type IdempotencyKey = string;

/**
 * URL for 3D Secure payment flow
 */
export type NextActionUrl = string | null;

/**
 * Payment error code during processing
 */
export type ErrorCode =
  | "AMOUNT_TOO_SMALL"
  | "AUTHENTICATION_ERROR"
  | "BUYER_CANCELED_PAYMENT_METHOD"
  | "CARD_NUMBER_INCORRECT"
  | "CUSTOMER_INVALID"
  | "CUSTOMER_NOT_FOUND"
  | "EXPIRED_PAYMENT_METHOD"
  | "FRAUD_SUSPECTED"
  | "FREE_GIFT_CARD_NOT_ALLOWED"
  | "INSUFFICIENT_FUNDS"
  | "INSUFFICIENT_INVENTORY"
  | "INVALID_CUSTOMER_BILLING_AGREEMENT"
  | "INVALID_PAYMENT_METHOD"
  | "INVALID_SHIPPING_ADDRESS"
  | "INVENTORY_ALLOCATIONS_NOT_FOUND"
  | "INVOICE_ALREADY_PAID"
  | "NON_TEST_ORDER_LIMIT_REACHED"
  | "PAYMENT_METHOD_DECLINED"
  | "PAYMENT_METHOD_INCOMPATIBLE_WITH_GATEWAY_CONFIG"
  | "PAYMENT_METHOD_NOT_FOUND"
  | "PAYMENT_PROVIDER_IS_NOT_ENABLED"
  | "PAYPAL_ERROR_GENERAL"
  | "PURCHASE_TYPE_NOT_SUPPORTED"
  | "TEST_MODE"
  | "TRANSIENT_ERROR"
  | "UNEXPECTED_ERROR"
  | null;

/**
 * Error message if billing attempt failed
 */
export type ErrorMessage = string | null;

/**
 * Referenced subscription ID
 */
export type SubscriptionId1 = string;

/**
 * Contract status at time of billing attempt
 */
export type ContractStatus =
  | "ACTIVE"
  | "CANCELLED"
  | "EXPIRED"
  | "FAILED"
  | "PAUSED"
  | "STALE";

/**
 * Customer ID (flattened from contract.customer.id)
 */
export type CustomerId1 = string;

/**
 * Computed status based on whether order exists
 */
export type Status = "successful" | "failed";

/**
 * Store name (will be set during processing)
 */
export type Store2 = string;

/**
 * Status
 */
export type Status1 =
  | "open#needs_attention"
  | "closed#resolved"
  | "closed#automatically_cancelled"
  | "closed#subscription_cancelled";

/**
 * Last Error Code
 */
export type LastErrorCode = string | null;

/**
 * Last Error Message
 */
export type LastErrorMessage = string | null;

/**
 * Closed At
 */
export type ClosedAt = string | null;

/**
 * The frequency, it can be either: DAY, WEEK, MONTH or YEAR.
 */
export type Interval = string;

/**
 * The number of intervals between each step in the given interval unit.
 */
export type IntervalCount = number;

/**
 * The Shopify GID of the billing attempt
 */
export type Id1 = string;

/**
 * The Shopify store identifier (without .myshopify.com) - if not provided, will be extracted from token
 */
export type Store3 = string | null;

/**
 * The subscription ID
 */
export type SubscriptionId2 = string;

/**
 * ID of the subscription that the shipping method should be modified on.
 */
export type SubscriptionId3 = string;

/**
 * Title of the shipping line delivery method that should be used for the upcoming orders. This should match the title that is configured in shopify delivery profiles. Will not change the title of the current delivery method if it is empty. Either delivery_method_title or delivery_price must be present
 */
export type DeliveryMethodTitle = string | null;

/**
 * The price of the delivery rate. This will default to the chosen title if nothing is input. Either delivery_method_title or delivery_price must be present
 */
export type DeliveryPrice = number | null;

/**
 * Email or identifier of the user/system initiating this action (required for audit trail)
 */
export type CausedBy2 = string;

/**
 * The store for which the rate should be calculated for. Note, this is without 'myshopify.com'
 */
export type Store4 = string;

/**
 * The shopify GID of the discount
 */
export type Id2 = string;

/**
 * Number of times the discount can be applied on recurring orders
 */
export type RecurringCycleLimit1 = number | null;

/**
 * Rejection reason if the discount is not valid anymore.
 */
export type RejectionReason = string | null;

/**
 * type of the discount. Can be AUTOMATIC_DISCOUNT, CODE_DISCOUNT or MANUAL
 */
export type Type = string;

/**
 * TRUE=discount is still active, FALSE=discount is not active anymore.
 */
export type IsActive = boolean;

/**
 * Title of the discount
 */
export type Title1 = string;

/**
 * Number of times the discount has already been applied on recurring orders
 */
export type UsageCount = number;

/**
 * for percentage discounts -> value between 1-100, for fixed discounts = discount amount
 */
export type Value1 = number;

/**
 * Value Type
 */
export type ValueType = "PERCENTAGE" | "FIXED";

/**
 * Shopify GID of the product. e.g. gid://shopify/Product/XXX
 */
export type ProductId1 = string | null;

/**
 * Shopify GID of the variant. e.g. gid://shopify/ProductVariant/XXX
 */
export type VariantId = string | null;

/**
 * Ordered quantity of the product.
 */
export type Quantity = number | null;

/**
 * the shopify GID of the line of the contract.
 */
export type Id3 = string;

/**
 * the title of the line of the contract item
 */
export type Title2 = string;

/**
 * The title of the variant
 */
export type VariantTitle = string | null;

/**
 * Link to the image of the variant
 */
export type VariantImage = string | null;

/**
 * The customer ID to create a token for
 */
export type CustomerId2 = string;

/**
 * The JWT access token for storefront API access
 */
export type Token = string;

/**
 * The token type (always 'Bearer')
 */
export type TokenType = string;

/**
 * Token expiry time in seconds from issuance
 */
export type ExpiresIn = number;

/**
 * Email or identifier of the user/system initiating this action (required for audit trail)
 */
export type CausedBy3 = string;

/**
 * Shopify customer ID (e.g., gid://shopify/Customer/456)
 */
export type CustomerId3 = string;

/**
 * Next billing date in YYYY-MM-DD format
 */
export type NextBillingDate = string;

/**
 * Billing interval (DAY, WEEK, MONTH, YEAR)
 */
export type Interval1 = "DAY" | "WEEK" | "MONTH" | "YEAR";

/**
 * Number of intervals between billings
 */
export type IntervalCount1 = number;

/**
 * Shopify customer payment method ID
 */
export type PaymentMethodId = string;

/**
 * Discount codes to apply
 */
export type DiscountCodes = string[] | null;

/**
 * Delivery price
 */
export type DeliveryPrice1 = number;

/**
 * Currency code (EUR, USD, etc.)
 */
export type CurrencyCode = string;

/**
 * Allow price overrides from the request
 */
export type AllowPriceOverride = boolean;

/**
 * The merchant's store identifier
 */
export type Store5 = string;

/**
 * List of permissions for the token
 */
export type Permissions = string[] | null;

/**
 * Optional description for the token
 */
export type Description = string | null;

/**
 * Unique name for this token (required)
 */
export type TokenName = string;

/**
 * Days until token expires (None for no expiry)
 */
export type ExpiresInDays = number | null;

/**
 * key of the custom attribute. e.g. one_time_add_on
 */
export type Key = string | null;

/**
 * value of the custom attribute. e.g. TRUE/FALSE
 */
export type Value2 = string | null;

/**
 * shopify GID of the discount that the custom discount config belongs to
 */
export type DiscountId = string | null;

/**
 * Discount title that was setup in eversubs admin
 */
export type Title3 = string | null;

/**
 * Discount description that was setup in eversubs admin
 */
export type Description1 = string | null;

/**
 * accepted values: ORDER, PRODUCT, SHIPPING
 */
export type DiscountClasses = string[] | null;

/**
 * whether there is any active step on the discount
 */
export type IsActive1 = boolean;

/**
 * the shopify GID of the customer associated with the contract.
 */
export type Id4 = string;

/**
 * email of customer
 */
export type Email = string | null;

/**
 * first name of customer
 */
export type FirstName1 = string | null;

/**
 * whether or not customer has bundling enabled. This will only be false if customer or customer support agent sets this metafield
 */
export type AutomaticallyBundleSubscriptions = boolean | null;

/**
 * the shopify GID of the customer associated with the contract.
 */
export type Id5 = string;

/**
 * The unique identifier for the customer.
 */
export type Id6 = string;

/**
 * The full name of the customer.
 */
export type Name1 = string;

/**
 * The email address of the customer.
 */
export type Email1 = string;

/**
 * A URL link to the customer's profile in the admin panel.
 */
export type CustomerLink = string;

/**
 * The subscription contract ID
 */
export type SubscriptionId4 = string;

/**
 * Store identifier (optional, defaults to authenticated store)
 */
export type Store6 = string | null;

/**
 * Number of delivery interval units (e.g., 4 for '4 weeks')
 */
export type IntervalCount2 = number;

/**
 * Delivery interval unit: 'DAY', 'WEEK', 'MONTH', or 'YEAR'
 */
export type IntervalUnit = string;

/**
 * Title of the delivery method. e.g. Kostenloser Versand / Standard Shipping
 */
export type Title4 = string | null;

/**
 * Price of the delivery rate that will be applied
 */
export type Price = number | null;

/**
 * only apply discount if order value exceeds minimum order value.
 */
export type MinimumOrderValue = MinumumOrderValue | null;

/**
 * List of collection ids that the discount should be applied to
 */
export type ApplyToCollections = string[] | null;

/**
 * List of collection ids that the discount should be applied to
 */
export type ApplyToProducts = string[] | null;

/**
 * List of collection ids that the discount should be applied to
 */
export type ApplyToProductVariants = string[] | null;

/**
 * List of product ids that need to be present to apply the discount
 */
export type MustIncludeProducts = string[] | null;

/**
 * Step
 */
export type Step = number;

/**
 * Recurring Cycle Limit
 */
export type RecurringCycleLimit2 = number;

/**
 * Usage Count
 */
export type UsageCount1 = number;

/**
 * Rejection Reason
 */
export type RejectionReason1 = string | null;

/**
 * whether this step is active
 */
export type IsActive2 = boolean;

export type Loc = (string | number)[];

export type Msg = string;

export type Type1 = string;

/**
 * Factor to adjust interval by. e.g. 0,5 -> 8 Weeks -> 4 Weeks
 */
export type AdjustmentFactor = number;

/**
 * ID of the line item
 */
export type Id7 = string;

/**
 * Title of the line item
 */
export type Title5 = string;

/**
 * Title of the variant
 */
export type VariantTitle1 = string | null;

/**
 * Product ID
 */
export type ProductId2 = string;

/**
 * Variant ID
 */
export type VariantId1 = string;

/**
 * Subscription ID for line items. Empty if added after order creation
 */
export type SubscriptionId5 = string | null;

/**
 * Original order ID from the contract
 */
export type OriginOrderId = string | null;

/**
 * Specific line item ID to update (required if contract has multiple items)
 */
export type LineItemId = string | null;

/**
 * When the token was created
 */
export type CreatedAt1 = string | null;

/**
 * The merchant's store identifier
 */
export type Store7 = string;

/**
 * When the token expires
 */
export type ExpiresAt = string | null;

/**
 * Days until expiry from creation
 */
export type ExpiresInDays1 = number | null;

/**
 * Last 4 characters of the token
 */
export type Last4 = string | null;

/**
 * New Next Billing Date
 */
export type NewNextBillingDate = string;

/**
 * ID of the order
 */
export type Id8 = string;

/**
 * Name of the order, typically prefixed with #
 */
export type Name2 = string;

/**
 * Total price of the order (after discounts, before taxes)
 */
export type Price1 = number;

/**
 * Total tax on the order
 */
export type Tax = number;

/**
 * Currency of the order
 */
export type Currency = string;

/**
 * Customer ID
 */
export type CustomerId4 = string;

/**
 * The id of the subscription to pause. This is in Shopify format, e.g. gid://shopify/SubscriptionContract/123456
 */
export type SubscriptionId6 = string;

/**
 * The id of the line item to pause. If not provided, pauses the entire contract. This is in Shopify format, e.g. gid://shopify/SubscriptionLine/789012
 */
export type LineItemId1 = string | null;

/**
 * The reason for pausing the subscription
 */
export type Reason = string;

/**
 * Email or identifier of who initiated this action (required for audit trail)
 */
export type CausedBy4 = string;

/**
 * Additional details about the cancellation reason
 */
export type OtherCancellationReason = string | null;

/**
 * The name of the payment instrument
 */
export type Name3 = string | null;

/**
 * If paypal is the instrument, paypal email.
 */
export type PaypalAccountEmail = string | null;

/**
 * The masked number of the card if it is card payment.
 */
export type MaskedNumber = string | null;

/**
 * Currency code for the price
 */
export type CurrencyCode1 = string;

/**
 * Amount of the price
 */
export type Amount = number;

/**
 * percentage or new_price
 */
export type AdjustmentType = "PERCENTAGE" | "FIXED";

/**
 * Factor to adjust interval by. e.g. 2 -> 3 quantity -> 6 quantity
 */
export type AdjustmentFactor1 = number;

/**
 * The line ids that need to be split into a new contract
 */
export type LineIds = string[];

/**
 * new status of subscription
 */
export type Status2 = "PAUSED" | "ACTIVE" | "CANCELLED";

/**
 * Reason for change of status
 */
export type Reason1 = string | null;

/**
 * The datetime that the change was processed at
 */
export type ProcessedAt = string | null;

/**
 * Email of the customer associated with the bulk update
 */
export type Email2 = string | null;

/**
 * Shopify GID of the customer
 */
export type CustomerId5 = string | null;

/**
 * status of the subscription
 */
export type SubscriptionStatus = string | null;

/**
 * whether or not the update was successful.
 */
export type UpdateStatus = string | null;

/**
 * Subscription ID that the changes were performed on
 */
export type SubscriptionId7 = string;

/**
 * the shopify GID of the contract.
 */
export type Id9 = string;

/**
 * the date where the contract is next to be billed
 */
export type NextBillingDate1 = string;

/**
 * The unique identifier for the subscription.
 */
export type SubscriptionId8 = string;

/**
 * The current status of the subscription (e.g., 'active').
 */
export type SubscriptionStatus1 = string;

/**
 * The next scheduled date for delivery.
 */
export type Nextbillingdate = string;

/**
 * The total amount of the line items, including currency.
 */
export type TotalLineItemAmount = number;

/**
 * The number of orders associated with this subscription.
 */
export type OrderCount = number;

/**
 * Shopify product variant ID
 */
export type ProductVariantId = string;

/**
 * Selling plan ID for subscription items
 */
export type SellingPlanId = string | null;

/**
 * Quantity of the item
 */
export type Quantity1 = number;

/**
 * Override price (only used if allow_price_override is true)
 */
export type CurrentPrice = number | null;

/**
 * The store identifier (with or without .myshopify.com)
 */
export type Store8 = string;

/**
 * Content of the message to be displayed to the customer
 */
export type Message1 = string;

/**
 * If message has expiration date it will be stored here.
 */
export type ExpirationDate = string | null;

/**
 * New variant ID.
 */
export type NewVariantId = string;

/**
 * Activity log entry for tracking operations and changes in the subscription system.
 */
export interface ActivityLog {
  /**
   * Name of the app involved in the log entry, useful for debugging and development. Can also include versions.
   */
  subscription_app_name: SubscriptionAppName;
  /**
   * Shopify store name.
   */
  store: Store;
  /**
   * Email of the creator or string indicating of the process that issued the changes
   */
  caused_by: CausedBy;
  /**
   * The datetime (in UTC) when the activity took place.
   */
  timestamp: Timestamp;
  /**
   * Group ID if multiple log should be grouped together.
   */
  transaction_group_id?: TransactionGroupId;
  /**
   * The type of activity
   */
  activity_type: ActivityType;
  /**
   * The subtype of the activity
   */
  activity_subtype?: ActivitySubtype | null;
  /**
   * Shopify customer ID.
   */
  related_to_customer?: RelatedToCustomer;
  /**
   * Shopify Subscription contract ID.
   */
  related_to_subscription?: RelatedToSubscription;
  /**
   * The log message.
   */
  message: Message;
  /**
   * Log level and severity of the log, the following levels are valid "DEBUG", "INFO", "WARNING", "ERROR" , "EMERGENCY"
   */
  log_level: LogLevel;
  /**
   * Additional structured data for the activity type, typically used to get information in a structured way
   */
  details?: Details;
}

/**
 * ActivityLog model for API responses (excludes internal fields like subscription_app_name).
 */
export interface ActivityLogResponse {
  store: string;
  caused_by: string;
  timestamp: string;
  transaction_group_id?: string | null;
  activity_type: ActivityType;
  activity_subtype?: ActivitySubtype | null;
  related_to_subscription?: string | null;
  related_to_customer?: string | null;
  message: string;
  log_level: string;
  details?: Record<string, any> | null;
}

/**
 * Conditions to find the relevant subscriptions.
 *
 * input:
 * discount_type: str #PERCENTAGE or FIXED
 * value: float
 * recurring_cycle_limit: int #Optional
 * title: str #Optional will default to SUBSCRIPTION_ADJUSTMENT_DISCOUNT.
 */
export interface AddDiscountConfig {
  type?: "discount";
}

/**
 * Request model for adding discounts to subscription.
 */
export interface AddDiscountRequest {
  /**
   * PERCENTAGE or FIXED
   */
  discount_type: DiscountType;
  /**
   * Percentage or fixed value of the discount.
   */
  value: Value;
  /**
   * If the discount is limited to a set amount of applications.
   */
  recurring_cycle_limit?: RecurringCycleLimit;
  /**
   * title of the discount to be created
   */
  title?: Title;
  /**
   * lines that the discount should be applied to. defaults to all. Otherwise comma seperated list of lines to apply the discount to
   */
  entitled_lines?: EntitledLines;
  /**
   * The Shopify store identifier (without .myshopify.com) - if not provided, will be extracted from token
   */
  store?: Store1;
  /**
   * The subscription ID
   */
  subscription_id: SubscriptionId;
  /**
   * Shopify customer ID for validation
   */
  customer_id: CustomerId;
  /**
   * Email of customer or name of process that triggers the change.
   */
  caused_by: CausedBy1;
}

/**
 * Response model for adding discounts operation.
 */
export interface AddDiscountResponse {
  success: boolean;
  message: string;
  subscription_id?: string | null;
  transaction_id?: string | null;
}

/**
 * Request model for adding line items to subscription.
 */
export interface AddLineItemRequest {
  /**
   * The subscription ID
   */
  subscription_id: SubscriptionId;
  /**
   * The Shopify store identifier (without .myshopify.com) - if not provided, will be extracted from token
   */
  store?: Store1;
  /**
   * Customer email for logging purposes
   */
  customer_email: CustomerEmail;
  /**
   * Shopify customer ID for validation
   */
  customer_id: CustomerId;
  /**
   * Shopify product ID
   */
  product_id: ProductId;
  /**
   * Line item details
   */
  line_item: SubscriptionLineInput;
}

/**
 * Response model for add line item operation.
 */
export interface AddLineItemResponse {
  success: boolean;
  message: string;
  subscription_id?: string | null;
  transaction_id?: string | null;
}

/**
 * Shipping address information.
 */
export interface Address {
  address1?: Address1;
  address2?: Address2;
  zip?: Zip;
  city?: City;
  company?: Company;
  country?: Country;
  country_code?: CountryCode;
  province_code?: ProvinceCode;
  first_name?: FirstName;
  last_name?: LastName;
  name?: Name;
}

/**
 * Base model for custom discounts.
 */
export interface BaseCustomDiscount {
  title: string;
  value: number;
  value_type: ValueType;
  once_per_order?: boolean;
  conditions?: DiscountConditions | null;
}

/**
 * Basic billing attempt info about creation.
 */
export interface BasicBillingAttempt {
  /**
   * Date that the billing attempt was created at.
   */
  created_at: string;
}

/**
 * Complete billing attempt model optimized for Firestore storage and BigQuery streaming.
 *
 * Use cases:
 * - Permanent storage of billing attempt history
 * - Analytics and reporting
 * - Audit trail for financial transactions
 * - Customer billing history tracking
 *
 * Design decisions:
 * - Flattened structure: Customer and subscription data are denormalized for:
 * * Efficient NoSQL queries without joins
 * * Direct BigQuery streaming without nested transformations
 * * Simpler indexing strategies
 * - Computed fields: Status field derived from order presence for query optimization
 * - Full error tracking: Complete error codes and messages for debugging
 *
 * This model is populated from Shopify webhooks and stored permanently,
 * unlike BillingAttemptLight which is used for transient processing.
 */
export interface BillingAttemptFull {
  /**
   * The Shopify GID of the billing attempt
   */
  id: Id;
  /**
   * When the billing attempt was created
   */
  created_at: CreatedAt;
  /**
   * When the billing attempt was completed
   */
  completed_at?: CompletedAt;
  /**
   * Unique key to avoid duplicate payments
   */
  idempotency_key: IdempotencyKey;
  /**
   * URL for 3D Secure payment flow
   */
  next_action_url?: NextActionUrl;
  /**
   * Payment error code during processing
   */
  error_code?: ErrorCode;
  /**
   * Error message if billing attempt failed
   */
  error_message?: ErrorMessage;
  /**
   * Referenced subscription ID
   */
  subscription_id: SubscriptionId1;
  /**
   * Contract status at time of billing attempt
   */
  contract_status: ContractStatus;
  /**
   * Customer ID (flattened from contract.customer.id)
   */
  customer_id: CustomerId1;
  /**
   * Related order if billing attempt was successful
   */
  order?: OrderFull | null;
  /**
   * Computed status based on whether order exists
   */
  status?: Status;
  /**
   * Store name (will be set during processing)
   */
  store?: Store2;
}

/**
 * Model for a billing attempt group matching AWS API structure.
 */
export interface BillingAttemptGroup {
  customer_id: string;
  created_at: string;
  status: Status1;
  attempts: BillingAttemptFull[];
  last_error_code?: LastErrorCode;
  last_error_message?: LastErrorMessage;
  closed_at?: ClosedAt;
}

/**
 * Response model for billing attempt groups with pagination support.
 */
export interface BillingAttemptGroupsResponse {
  billing_attempt_groups: BillingAttemptGroup[];
  /**
   * Cursor for pagination
   */
  next_cursor?: Record<string, any> | null;
}

/**
 * Response model for billing attempts list.
 */
export interface BillingAttemptsResponse {
  billing_attempts: BillingAttemptFull[];
  /**
   * Cursor for pagination
   */
  next_cursor?: string | null;
}

/**
 * Billing policy with interval and frequency.
 */
export interface BillingPolicy {
  /**
   * The frequency, it can be either: DAY, WEEK, MONTH or YEAR.
   */
  interval: Interval;
  /**
   * The number of intervals between each step in the given interval unit.
   */
  interval_count: IntervalCount;
}

/**
 * Model for the main document in the 'bulk_updates' collection.
 *
 * Including bulk update id and status determined from success_count, error_count and total_affected_subscriptions
 */
export interface BulkUpdateJobReturn {
  dry_run?: boolean;
  bulk_update_name: string;
  /**
   * Datetime when the bulk update was initiated
   */
  triggered_at: string;
  /**
   * Number of subscriptions included in update.
   */
  total_affected_subscriptions: number;
  /**
   * Number of subscriptions that have been successfully processed
   */
  success_count?: number;
  /**
   * Number of subscriptions that encountered errors while being processed
   */
  error_count?: number;
  update_config: UpdateConfig;
  /**
   * Identifier for the bulk update to guarantee traceability
   */
  bulk_update_id: string;
  /**
   * SUCCESS, ERROR or IN_PROGRESS. UNKNOWN needs investigation from backend
   */
  status: string;
}

/**
 * Response model for bulk update by ID and updated contracts with pagination support.
 */
export interface BulkUpdateResponse {
  /**
   * Cursor for pagination - pass this value to get the next page of results
   */
  next_cursor?: string | null;
  data: BulkUpdateReturn;
}

/**
 * Model for the main document in the 'bulk_updates' collection and the subcollection 'operations'.
 *
 * Subcollection holds the updates of one subscription contract
 */
export interface BulkUpdateReturn {
  dry_run?: boolean;
  bulk_update_name: string;
  /**
   * Datetime when the bulk update was initiated
   */
  triggered_at: string;
  /**
   * Number of subscriptions included in update.
   */
  total_affected_subscriptions: number;
  /**
   * Number of subscriptions that have been successfully processed
   */
  success_count?: number;
  /**
   * Number of subscriptions that encountered errors while being processed
   */
  error_count?: number;
  update_config: UpdateConfig;
  /**
   * Identifier for the bulk update to guarantee traceability
   */
  bulk_update_id: string;
  /**
   * SUCCESS, ERROR or IN_PROGRESS. UNKNOWN needs investigation from backend
   */
  status: string;
  operations: SubscriptionBulkUpdateOperation[];
}

/**
 * Response model for bulk updates with pagination support.
 */
export interface BulkUpdatesResponse {
  /**
   * Cursor for pagination - pass this value to get the next page of results
   */
  next_cursor?: string | null;
  data: BulkUpdateJobReturn[];
}

/**
 * Request model for calculating shipping rates for a set of products.
 */
export interface CalculateShippingRatePayload {
  /**
   * The store for which the rate should be calculated for. Note, this is without 'myshopify.com'
   */
  store: Store4;
  /**
   * The list of products to be taken into account for the shipping rate
   */
  products: Product[];
  /**
   * Delivery method of the contract
   */
  delivery_method: DeliveryMethod;
}

/**
 * Request model for changing the shipping method of a subscription.
 */
export interface ChangeShippingMethodPayload {
  /**
   * The store for which the rate should be calculated for. Note, this is without 'myshopify.com'
   */
  store: Store4;
  /**
   * ID of the subscription that the shipping method should be modified on.
   */
  subscription_id: SubscriptionId3;
  /**
   * Title of the shipping line delivery method that should be used for the upcoming orders. This should match the title that is configured in shopify delivery profiles. Will not change the title of the current delivery method if it is empty. Either delivery_method_title or delivery_price must be present
   */
  delivery_method_title?: DeliveryMethodTitle;
  /**
   * The price of the delivery rate. This will default to the chosen title if nothing is input. Either delivery_method_title or delivery_price must be present
   */
  delivery_price?: DeliveryPrice;
  /**
   * Email or identifier of the user/system initiating this action (required for audit trail)
   */
  caused_by: CausedBy2;
}

/**
 * Response model for changed delivery method on subscription contract operation.
 */
export interface ChangeShippingMethodResponse {
  success: boolean;
  subscription_id?: string | null;
  message: string;
  transaction_id?: string | null;
  details?: Record<string, any> | null;
}

/**
 * Bundle of subscription contracts to be charged together.
 *
 * Represents multiple subscriptions being billed in a single transaction to:
 * - Reduce payment processing fees
 * - Improve customer experience (one charge vs multiple)
 * - Simplify failed payment handling
 *
 * Key features:
 * - Idempotency key prevents duplicate charges
 * - Tracks retry attempts (PrevChargeErrors counter)
 * - Configurable delivery cost handling
 * - Customer notification preferences
 *
 * The idempotency key format encodes:
 * - Billing dates for each contract group
 * - Contract IDs being charged
 * - Number of previous failed attempts
 */
export interface ChargeBundle {
  /**
   * the shopify GID of the customer associated with the contract.
   */
  customer_id: string;
  /**
   * All contracts associated with the charge for a customer / store / date
   */
  contracts: SubscriptionContractForProcessor[];
  /**
   * Shopify store that the customer & contracts are stored.
   */
  store: string;
  /**
   * Allows to override the 'triggered by' field in logs to make sure that the logs reflect who initiated the action.
   */
  caused_by?: string | null;
  /**
   * Unique string identifier per Charge. Shopify uses idempotency key to prevent accidental multiple charges of the same request. It is of the format: date_1:contract_1,contract_2|date_2:contract_3|PrevChargeErrors:X e.g. 20240614:9170682045,9179234493|20240616:9170616509,9179136189|PrevChargeErrors:5 the dates are the current next billing date of the bundle. Note: This key changes if a new contract is added to the bundle later on, i.e. a customer has failing billing attempts on contract_1 and contract_2, once a new contract is added, the counter starts anew.
   */
  idempotency_key: string;
  /**
   * TRUE=Delivery costs are calculated with shipping profile of respective store and items in bundle.FALSE=Delivery costs will not be calculated and set to 0
   */
  apply_delivery_costs?: boolean;
  /**
   * Specifies if customer should be informed about a failed attempt and be prompted to update their payment method
   */
  notify_customer_about_failed_attempt?: boolean;
  /**
   * After successfully charging the contract, calculate the next charge date either starting fromtoday (i.e. today + interval), starting from next billing date (i.e. next_billing_date + interval) or simply leave it unchanged (leave_next_billing_date_unchanged)
   */
  next_billing_date_reference?:
    | "today"
    | "original_next_billing_date"
    | "leave_next_billing_date_unchanged";
}

/**
 * Request model for charging subscriptions immediately.
 */
export interface ChargeNowRequest {
  /**
   * Store identifier (optional, defaults to authenticated store)
   */
  store?: string | null;
  /**
   * The base subscription IDs that should be charged now, irrespective of next charge date. These are in Shopify format, e.g. gid://shopify/SubscriptionContract/3259072718
   */
  subscription_ids?: string[] | null;
  /**
   * After successfully charging the contract, calculate the next charge date either starting from today (i.e. today + interval), starting from next billing date (i.e. next_billing_date + interval) or simply leave it unchanged (leave_as_is)
   */
  next_billing_date_reference?:
    | "today"
    | "original_next_billing_date"
    | "leave_next_billing_date_unchanged";
  /**
   * The customer that should be charged. Note that this will charge only the currently due subscriptions and will ignore subscription_ids and next_charge_date values.
   */
  customer_id?: string | null;
  /**
   * Specifies if customer should be informed about a failed attempt and be prompted to update their payment method
   */
  notify_customer_about_failed_attempt?: boolean | null;
  /**
   * Mandatory field for audit trail. Allows to override the triggered by field in logs to make sure that the logs reflect who actually did it.
   */
  caused_by?: string;
}

/**
 * Response model for charge now operation results.
 */
export interface ChargeNowResponse {
  charge_bundles: ChargeBundle[];
  /**
   * Status message describing the outcome
   */
  message: string;
}

/**
 * Conditions to find the relevant subscriptions.
 *
 * input:
 * variant_id: str
 * next_billing_date: date
 * store: str.
 */
export interface Conditions {
  /**
   * The variant_id to be used to identify the subscriptions that need to be changed
   */
  variant_id: string;
  /**
   * If subscriptions need to be moved this will be the max billing date to include in change
   */
  next_billing_date_max?: string | null;
  /**
   * If subscriptions need to be moved this will be the max creation date to include in change. Subscriptions created prior to that date will not be updated.
   */
  created_at_max?: string | null;
  /**
   * If subscriptions need to be moved this will be the min creation date to include in change. Subscriptions created after to that date will not be updated.
   */
  created_at_min?: string | null;
  /**
   * subscription = only update subscription items. one_time = only update one time items
   */
  purchase_type?: "subscription" | "one_time" | null;
  /**
   * Which subscriptions to be updated. Filter by ACTIVE, PAUSED, CANCELLED and any combination of them
   */
  subscription_status?:
    | "ACTIVE"
    | "CANCELLED"
    | "EXPIRED"
    | "FAILED"
    | "PAUSED"
    | "STALE"
    | null;
  /**
   * Shopify ID of subscriptions that should be taken into account for the update.
   */
  subscription_id?: string | null;
  /**
   * The price that the subscriptions should be updated to. Subscriptions that already have this price will not be included in the update
   */
  price?: number | null;
}

/**
 * Contract-specific discount information.
 */
export interface ContractDiscounts {
  /**
   * Shopify GID of the discount
   */
  id: Id2;
  /**
   * Number of times the discount can be applied on recurring orders
   */
  recurring_cycle_limit?: RecurringCycleLimit1;
  /**
   * Rejection reason if the discount is not valid anymore.
   */
  rejection_reason?: RejectionReason;
  /**
   * type of the discount. Can be AUTOMATIC_DISCOUNT, CODE_DISCOUNT or MANUAL
   */
  type: Type;
  /**
   * TRUE=discount is still active, FALSE=discount is not active anymore.
   */
  is_active: IsActive;
  /**
   * Title of the discount
   */
  title: Title1;
  /**
   * Number of times the discount has already been applied on recurring orders
   */
  usage_count: UsageCount;
  /**
   * for percentage discounts -> value between 1-100, for fixed discounts = discount amount
   */
  value: Value1;
  value_type: ValueType;
}

/**
 * Product line item within a subscription contract.
 *
 * Represents a single product/variant that's part of a subscription.
 * Extends Product with:
 * - Line item ID for contract management
 * - Title for display
 * - Custom attributes for metadata
 * - Current pricing for billing
 *
 * Used in SubscriptionContractWithLines for tracking all products
 * in a customer's subscription.
 */
export interface ContractLine {
  /**
   * Shopify GID of the product. e.g. gid://shopify/Product/XXX
   */
  product_id?: ProductId1;
  /**
   * Shopify GID of the variant. e.g. gid://shopify/ProductVariant/XXX
   */
  variant_id?: VariantId;
  /**
   * Ordered quantity of the product.
   */
  quantity?: Quantity;
  /**
   * Discounted price of the line
   */
  line_discounted_price?: Price_ | null;
  /**
   * the shopify GID of the line of the contract.
   */
  id: Id3;
  /**
   * the title of the line of the contract item
   */
  title: Title2;
  /**
   * Custom attributes of the contract item
   */
  custom_attributes?: CustomAttribute[] | null;
  /**
   * Current price of the contract item
   */
  current_price?: Price_ | null;
  /**
   * The title of the variant
   */
  variant_title?: VariantTitle;
  /**
   * Link to the image of the variant
   */
  variant_image?: VariantImage;
}

/**
 * Request model for creating a storefront token.
 */
export interface CreateStorefrontTokenRequest {
  /**
   * The store identifier (with or without .myshopify.com)
   */
  store: Store8;
  /**
   * The customer ID to create a token for
   */
  customer_id: CustomerId2;
}

/**
 * Response model for storefront token creation.
 */
export interface CreateStorefrontTokenResponse {
  /**
   * The JWT access token for storefront API access
   */
  token: Token;
  /**
   * The token type (always 'Bearer')
   */
  token_type?: TokenType;
  /**
   * Token expiry time in seconds from issuance
   */
  expires_in: ExpiresIn;
}

/**
 * Request model for creating a new subscription contract.
 */
export interface CreateSubscriptionContractRequest {
  /**
   * Email or identifier of the user/system initiating this action (required for audit trail)
   */
  caused_by: CausedBy3;
  /**
   * Shopify customer ID (e.g., gid://shopify/Customer/456)
   */
  customer_id: CustomerId3;
  /**
   * Line items for the subscription
   */
  lines: SubscriptionLineInputOptionalPrice[];
  /**
   * Next billing date in YYYY-MM-DD format
   */
  next_billing_date: NextBillingDate;
  /**
   * Billing interval (DAY, WEEK, MONTH, YEAR)
   */
  interval?: Interval1;
  /**
   * Number of intervals between billings
   */
  interval_count?: IntervalCount1;
  /**
   * Shopify customer payment method ID
   */
  payment_method_id: PaymentMethodId;
  /**
   * Delivery address for the subscription
   */
  delivery_address: Address;
  /**
   * Discount codes to apply
   */
  discount_codes?: DiscountCodes;
  /**
   * Delivery price
   */
  delivery_price?: DeliveryPrice1;
  /**
   * Currency code (EUR, USD, etc.)
   */
  currency_code?: CurrencyCode;
  /**
   * Allow price overrides from the request
   */
  allow_price_override?: AllowPriceOverride;
  /**
   * Custom attributes for the contract
   */
  custom_attributes?: CustomAttribute[] | null;
  /**
   * Store identifier (optional, defaults to authenticated store)
   */
  store?: Store6;
}

/**
 * Response model for create subscription contract operation.
 */
export interface CreateSubscriptionContractResponse {
  success: boolean;
  subscription_id?: string | null;
  message: string;
  transaction_id?: string | null;
  details?: Record<string, any> | null;
}

/**
 * Request model for creating a merchant token.
 */
export interface CreateTokenRequest {
  /**
   * The merchant's store identifier
   */
  store: Store5;
  /**
   * List of permissions for the token
   */
  permissions?: Permissions;
  /**
   * Optional description for the token
   */
  description?: Description;
  /**
   * Unique name for this token (required)
   */
  token_name: TokenName;
  /**
   * Days until token expires (None for no expiry)
   */
  expires_in_days?: ExpiresInDays;
}

/**
 * Response model for token creation.
 */
export interface CreateTokenResponse {
  /**
   * The generated SOT token
   */
  token: Token;
  /**
   * The token name
   */
  token_name: TokenName;
  /**
   * The merchant's store identifier
   */
  store: Store5;
  message?: string;
}

/**
 * Custom attribute for line items and contracts.
 */
export interface CustomAttribute {
  /**
   * key of the custom attribute. e.g. one_time_add_on
   */
  key: Key;
  /**
   * value of the custom attribute. e.g. TRUE/FALSE
   */
  value: Value2;
}

/**
 * Represents a complete discount sequence.
 *
 * It automatically sorts steps before validation, making it robust against unordered input.
 */
export interface CustomDiscount {
  /**
   * shopify GID of the discount that the custom discount config belongs to
   */
  discount_id?: DiscountId;
  /**
   * Discount title that was setup in eversubs admin
   */
  title?: Title3;
  /**
   * Discount description that was setup in eversubs admin
   */
  description?: Description1;
  /**
   * accepted values: ORDER, PRODUCT, SHIPPING
   */
  discount_classes?: DiscountClasses;
  /**
   * accepted values: ORDER, PRODUCT, SHIPPING
   */
  initial_discount?: BaseCustomDiscount | null;
  steps: DiscountStep[];
  /**
   * whether there is any active step on the discount
   */
  is_active?: IsActive1;
}

/**
 * Customer model with extended information including discounts and bundling preferences.
 */
export interface Customer {
  /**
   * the shopify GID of the customer associated with the contract.
   */
  id: Id4;
  /**
   * email of customer
   */
  email?: Email;
  /**
   * first name of customer
   */
  first_name?: FirstName1;
  /**
   * whether or not customer has bundling enabled. This will only be false if customer or customer support agent sets this metafield
   */
  automatically_bundle_subscriptions?: AutomaticallyBundleSubscriptions;
  /**
   * Manual discounts on the customer that will be applied to subscription orders if valid
   */
  customer_discounts?: CustomDiscount[] | null;
}

/**
 * Customer payment method information.
 */
export interface CustomerPaymentMethod {
  /**
   * the shopify GID of the customer payment method.
   */
  id?: Id5 | null;
  /**
   * Details about the payment method
   */
  instrument?: PaymentInstrument | null;
}

/**
 * Response model for customer by ID and details about subscriptions.
 */
export interface CustomerWithSubscriptionDetails {
  /**
   * The unique identifier for the customer.
   */
  id: Id6;
  /**
   * The full name of the customer.
   */
  name: Name1;
  /**
   * The email address of the customer.
   */
  email: Email1;
  /**
   * A list of the customer's subscriptions.
   */
  subscriptions?: SubscriptionDetails[];
  /**
   * A URL link to the customer's profile in the admin panel.
   */
  customer_link: CustomerLink;
}

/**
 * Base request model for delivery interval changes.
 */
export interface DeliveryIntervalRequest {
  /**
   * The subscription contract ID
   */
  subscription_id: SubscriptionId4;
  /**
   * Store identifier (optional, defaults to authenticated store)
   */
  store: Store6;
  /**
   * Number of delivery interval units (e.g., 4 for '4 weeks')
   */
  interval_count: IntervalCount2;
  /**
   * Delivery interval unit: 'DAY', 'WEEK', 'MONTH', or 'YEAR'
   */
  interval_unit: IntervalUnit;
}

/**
 * Base response model for delivery interval changes.
 */
export interface DeliveryIntervalResponse {
  message: string;
  subscription_id: string;
  interval_count: number;
  interval_unit: string;
}

/**
 * Delivery method with address and title.
 */
export interface DeliveryMethod {
  /**
   * Shipping delivery method
   */
  address?: Address | null;
  /**
   * Title of the delivery method. e.g. Kostenloser Versand / Standard Shipping
   */
  title?: Title4;
}

/**
 * Delivery policy with interval and frequency.
 */
export interface DeliveryPolicy {
  /**
   * The frequency, it can be either: DAY, WEEK, MONTH or YEAR.
   */
  interval: Interval;
  /**
   * The number of intervals between each step in the given interval unit.
   */
  interval_count: IntervalCount;
}

/**
 * Delivery rate with title and price.
 */
export interface DeliveryRate {
  /**
   * Title of the delivery method. e.g. Kostenloser Versand / Standard Shipping
   */
  title?: Title4;
  /**
   * Price of the delivery rate that will be applied
   */
  price?: Price;
}

/**
 * Conditions for applying discounts.
 */
export interface DiscountConditions {
  /**
   * only apply discount if order value exceeds minimum order value.
   */
  minimum_order_value?: MinimumOrderValue;
  /**
   * List of collection ids that the discount should be applied to
   */
  apply_to_collections?: ApplyToCollections;
  /**
   * List of collection ids that the discount should be applied to
   */
  apply_to_products?: ApplyToProducts;
  /**
   * List of collection ids that the discount should be applied to
   */
  apply_to_product_variants?: ApplyToProductVariants;
  /**
   * List of product ids that need to be present to apply the discount
   */
  must_include_products?: MustIncludeProducts;
}

/**
 * Discount step for progressive discounts.
 */
export interface DiscountStep {
  title: string;
  value: number;
  value_type: ValueType;
  once_per_order?: boolean;
  conditions?: DiscountConditions | null;
  step: Step;
  recurring_cycle_limit: RecurringCycleLimit2;
  usage_count?: UsageCount1;
  rejection_reason?: RejectionReason1;
  /**
   * whether this step is active
   */
  is_active?: IsActive2;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * Update Object for interval adjustment.
 *
 * input:
 * adjustment_factor: float.
 */
export interface IntervalUpdateConfig {
  type?: "interval";
  /**
   * Factor to adjust interval by. e.g. 0,5 -> 8 Weeks -> 4 Weeks
   */
  adjustment_factor: AdjustmentFactor;
}

/**
 * Order line item with full product and subscription details.
 *
 * Represents a single product/variant in an order created by a successful billing attempt.
 * Includes subscription linkage to track which subscription contract generated this line item.
 * Used in OrderFull for complete order tracking.
 */
export interface LineItem {
  /**
   * ID of the line item
   */
  id: Id7;
  /**
   * Title of the line item
   */
  title: Title5;
  /**
   * Title of the variant
   */
  variant_title?: VariantTitle1;
  /**
   * Product ID
   */
  product_id: ProductId2;
  /**
   * Variant ID
   */
  variant_id: VariantId1;
  /**
   * Subscription ID for line items. Empty if added after order creation
   */
  subscription_id?: SubscriptionId5;
  /**
   * Original order ID from the contract
   */
  origin_order_id?: OriginOrderId;
}

/**
 * Request model for line item specific delivery interval changes.
 */
export interface LineItemDeliveryIntervalRequest {
  /**
   * The subscription contract ID
   */
  subscription_id: SubscriptionId4;
  /**
   * Store identifier (optional, defaults to authenticated store)
   */
  store: Store6;
  /**
   * Number of delivery interval units (e.g., 4 for '4 weeks')
   */
  interval_count: IntervalCount2;
  /**
   * Delivery interval unit: 'DAY', 'WEEK', 'MONTH', or 'YEAR'
   */
  interval_unit: IntervalUnit;
  /**
   * Specific line item ID to update (required if contract has multiple items)
   */
  line_item_id?: LineItemId;
}

/**
 * Response model for line item specific delivery interval changes.
 */
export interface LineItemDeliveryIntervalResponse {
  message: string;
  subscription_id: string;
  interval_count: number;
  interval_unit: string;
  line_item_id?: string | null;
}

/**
 * Response model for listing tokens.
 */
export interface ListTokensResponse {
  /**
   * The merchant's store identifier
   */
  store: Store7;
  /**
   * List of token metadata
   */
  tokens: TokenInfo[];
  /**
   * Total number of tokens
   */
  total: number;
  /**
   * Number of active tokens
   */
  active_count: number;
}

/**
 * Response model for activity logs with pagination support.
 */
export interface LogsResponse {
  logs: ActivityLogResponse[];
  next_cursor?: string | null;
}

/**
 * Minimum order value for discount conditions.
 */
export interface MinumumOrderValue {
  amount: number;
  currency: string;
}

/**
 * Input.
 *
 * next_billing_date: date.
 */
export interface NextBillingDateUpdateConfig {
  type?: "next_billing_date";
  /**
   * New Next Billing Date
   */
  new_next_billing_date: NewNextBillingDate;
}

/**
 * Complete order information from a successful billing attempt.
 *
 * Contains all order details including:
 * - Financial data (price, tax, currency)
 * - Customer information
 * - Complete line items with product/variant details
 *
 * Used in BillingAttemptFull for storing successful billing attempts
 * with full transaction details in Firestore.
 */
export interface OrderFull {
  /**
   * ID of the order
   */
  id: Id8;
  /**
   * Name of the order, typically prefixed with #
   */
  name: Name2;
  /**
   * Total price of the order (after discounts, before taxes)
   */
  price: Price1;
  /**
   * Total tax on the order
   */
  tax: Tax;
  /**
   * Currency of the order
   */
  currency: Currency;
  /**
   * Customer ID
   */
  customer_id: CustomerId4;
  /**
   * Line items on the order
   */
  line_items?: LineItem[];
}

/**
 * Request model for pausing a subscription contract.
 */
export interface PauseContractRequest {
  /**
   * The store identifier (with or without .myshopify.com)
   */
  store: Store8;
  /**
   * The id of the subscription to pause. This is in Shopify format, e.g. gid://shopify/SubscriptionContract/123456
   */
  subscription_id: SubscriptionId6;
  /**
   * The id of the line item to pause. If not provided, pauses the entire contract. This is in Shopify format, e.g. gid://shopify/SubscriptionLine/789012
   */
  line_item_id?: LineItemId1;
  /**
   * The reason for pausing the subscription
   */
  reason: Reason;
  /**
   * Email or identifier of who initiated this action (required for audit trail)
   */
  caused_by: CausedBy4;
  /**
   * Additional details about the cancellation reason
   */
  other_cancellation_reason?: OtherCancellationReason;
}

/**
 * Response model for pause contract operation.
 */
export interface PauseContractResponse {
  contract: SubscriptionContractFull | null;
  message: string;
}

/**
 * Payment instrument infos. Differs between paypal, card and shop pay.
 */
export interface PaymentInstrument {
  /**
   * The name of the payment instrument
   */
  name?: Name3;
  /**
   * If paypal is the instrument, paypal email.
   */
  paypal_account_email?: PaypalAccountEmail;
  /**
   * The masked number of the card if it is card payment.
   */
  masked_number?: MaskedNumber;
}

/**
 * Price information with currency and amount.
 */
export interface Price_ {
  /**
   * Currency code for the price
   */
  currency_code: CurrencyCode1;
  /**
   * Amount of the price
   */
  amount: Amount;
}

/**
 * Update Object for changing price.
 *
 * input:
 * adjustment_type: str = PERCENTAGE or FIXED
 * value: float (percentage increase or fixed new price).
 */
export interface PriceUpdateConfig {
  type?: "price";
  /**
   * percentage or new_price
   */
  adjustment_type: AdjustmentType;
  value: number;
}

/**
 * Base product model with essential fields.
 *
 * Foundation for product-related models. Contains:
 * - Product and variant IDs (Shopify GIDs)
 * - Quantity
 * - Discounted pricing
 *
 * Extended by more specific product models.
 */
export interface Product {
  /**
   * Shopify GID of the product. e.g. gid://shopify/Product/XXX
   */
  product_id?: ProductId1;
  /**
   * Shopify GID of the variant. e.g. gid://shopify/ProductVariant/XXX
   */
  variant_id?: VariantId;
  /**
   * Ordered quantity of the product.
   */
  quantity?: Quantity;
  /**
   * Discounted price of the line
   */
  line_discounted_price?: Price_ | null;
}

/**
 * Input.
 *
 * adjustment_factor: float.
 */
export interface QuantityUpdateConfig {
  type?: "quantity";
  /**
   * Factor to adjust interval by. e.g. 2 -> 3 quantity -> 6 quantity
   */
  adjustment_factor: AdjustmentFactor1;
}

/**
 * Configuration for removing line items.
 */
export interface RemoveLineConfig {
  type?: "line_removal";
  variant_id: string;
}

/**
 * Request model for resuming a paused subscription contract.
 */
export interface ResumeContractRequest {
  /**
   * The store identifier (with or without .myshopify.com)
   */
  store: Store8;
  /**
   * The id of the subscription to resume. This is in Shopify format, e.g. gid://shopify/SubscriptionContract/123456
   */
  subscription_id: SubscriptionId6;
  /**
   * The id of the line item to resume. Required for multi-product subscriptions. This is in Shopify format, e.g. gid://shopify/SubscriptionLine/789012
   */
  line_item_id?: LineItemId1;
  /**
   * Email or identifier of who initiated this action (required for audit trail)
   */
  caused_by: CausedBy4;
}

/**
 * Response model for resume contract operation.
 */
export interface ResumeContractResponse {
  contract: SubscriptionContractFull | null;
  message: string;
}

/**
 * Request model for revoking a merchant token.
 */
export interface RevokeTokenRequest {
  /**
   * The merchant's store identifier
   */
  store: Store7;
  /**
   * Specific token to revoke, or None to revoke all tokens for the merchant
   */
  token_name?: string | null;
}

/**
 * Response model for token revocation.
 */
export interface RevokeTokenResponse {
  /**
   * Whether the revocation was successful
   */
  success: boolean;
  /**
   * Status message
   */
  message: string;
}

/**
 * Request model for splitting a subscription contract.
 */
export interface SplitContractRequest {
  /**
   * The store identifier (with or without .myshopify.com)
   */
  store: Store8;
  /**
   * The id of the subscription that needs to be split. This is in Shopify format, e.g. gid://shopify/SubscriptionContract/3259072718
   */
  subscription_id: SubscriptionId6;
  /**
   * The line ids that need to be split into a new contract
   */
  line_ids: LineIds;
}

/**
 * Return type for contract splitting operations.
 */
export interface SplittedContractsReturn {
  /**
   * The original contract after splitting (the line to split should not be present anymore)
   */
  original_contract: SubscriptionContractFull;
  /**
   * The new contract resulting from splitting (the line to split should be the only one present)
   */
  new_contract: SubscriptionContractFull;
}

/**
 * Update Object for updating subscription status.
 *
 * input:
 * status: str = PAUSED, ACTIVE or CANCELLED.
 */
export interface StatusUpdateConfig {
  type?: "status";
  /**
   * new status of subscription
   */
  status: Status2;
  /**
   * Reason for change of status
   */
  reason?: Reason1;
}

/**
 * Slim version of subscription update information.
 */
export interface SubscriptionBulkUpdateOperation {
  /**
   * The datetime that the change was processed at
   */
  processed_at?: ProcessedAt;
  /**
   * Email of the customer associated with the bulk update
   */
  email?: Email2;
  /**
   * Shopify GID of the customer
   */
  customer_id?: CustomerId5;
  /**
   * status of the subscription
   */
  subscription_status?: SubscriptionStatus;
  /**
   * whether or not the update was successful.
   */
  update_status?: UpdateStatus;
  /**
   * List of all updates that took place
   */
  updates?: UpdateDetailStatus[];
  /**
   * Subscription ID that the changes were performed on
   */
  subscription_id: SubscriptionId7;
}

/**
 * Subscription contract model optimized for charge processing workflows.
 *
 * Used by the charge processor for:
 * - Creating billing attempts
 * - Calculating delivery costs
 * - Managing bundle states
 * - Processing concatenated charges
 *
 * Contains all fields needed for charging logic without the overhead
 * of full contract details like revision tracking or creation timestamps.
 *
 * Key differences from SubscriptionContractFull:
 * - Simplified delivery_price (float vs Price object)
 * - No revision tracking
 * - No timestamp fields
 * - Focused on operational data for charging
 */
export interface SubscriptionContractForProcessor {
  /**
   * the shopify GID of the contract.
   */
  id: Id9;
  /**
   * the date where the contract is next to be billed
   */
  next_billing_date: NextBillingDate1;
  /**
   * The lines of the contract (the first one is the original contract item. the following ones are either concatenated items or one time add ons
   */
  lines: ContractLine[];
  /**
   * Billing policy of the contract
   */
  billing_policy: BillingPolicy | null;
  /**
   * customer data
   */
  customer: Customer;
  /**
   * Delivery method of the contract
   */
  delivery_method: DeliveryMethod;
  /**
   * Current delivery costs of the contract
   */
  delivery_price: number;
  /**
   * Custom attributes of the contract
   */
  custom_attributes?: CustomAttribute[] | null;
}

/**
 * Full subscription contract with all fields.
 */
export interface SubscriptionContractFull {
  /**
   * the shopify GID of the contract.
   */
  id: Id9;
  /**
   * the date where the contract is next to be billed
   */
  next_billing_date: NextBillingDate1;
  /**
   * Billing policy of the contract
   */
  billing_policy: BillingPolicy | null;
  /**
   * customer data
   */
  customer: Customer;
  /**
   * The lines of the contract (the first one is the original contract item. the following ones are either concatenated items or one time add ons
   */
  lines: ContractLine[];
  /**
   * Payment method of the customer
   */
  customer_payment_method?: CustomerPaymentMethod | null;
  /**
   * All billing attempts attached to the contract.
   */
  billing_attempts?: BasicBillingAttempt[];
  /**
   * Delivery policy of the contract
   */
  delivery_policy: DeliveryPolicy;
  /**
   * Custom attributes of the contract
   */
  custom_attributes?: CustomAttribute[] | null;
  /**
   * Delivery method of the contract
   */
  delivery_method: DeliveryMethod;
  /**
   * The delivery price for each billing of the subscription contract.
   */
  delivery_price: Price_ | null;
  /**
   * List of discounts on the contract. If they have a rejection reason will no longer be applied
   */
  discounts?: ContractDiscounts[] | null;
  /**
   * Revision id indicates a version of the contract, it's increasing but not necessarily every number is being used
   */
  revision_id: number;
  /**
   * The datetime, when the contract was last updated
   */
  updated_at: string;
  /**
   * The datetime, when the contract was created
   */
  created_at: string;
  /**
   * The original checkout order that the contract has been created through. This is only correct for the contracts that have been created through eversubs.
   */
  origin_order_id?: string | null;
  /**
   * The status of the contract.
   */
  status?:
    | "ACTIVE"
    | "CANCELLED"
    | "EXPIRED"
    | "FAILED"
    | "PAUSED"
    | "STALE"
    | null;
}

/**
 * A single customer subscription.
 */
export interface SubscriptionDetails {
  /**
   * The unique identifier for the subscription.
   */
  subscription_id: SubscriptionId8;
  /**
   * The current status of the subscription (e.g., 'active').
   */
  subscription_status: SubscriptionStatus1;
  /**
   * The next scheduled date for delivery.
   */
  nextBillingDate: Nextbillingdate;
  /**
   * The total amount of the line items, including currency.
   */
  total_line_item_amount: TotalLineItemAmount;
  /**
   * The number of orders associated with this subscription.
   */
  order_count: OrderCount;
}

/**
 * API input for adding line items to existing subscriptions.
 *
 * Used by add_line_item endpoint. Requires explicit price since the
 * subscription already exists with its own pricing structure.
 */
export interface SubscriptionLineInput {
  /**
   * Shopify product variant ID
   */
  product_variant_id: ProductVariantId;
  /**
   * Selling plan ID for subscription items
   */
  selling_plan_id?: SellingPlanId;
  /**
   * Quantity of the item
   */
  quantity?: Quantity1;
  /**
   * Custom attributes for the line item
   */
  custom_attributes?: CustomAttribute[] | null;
  /**
   * Current price of the line item (required for add_line_item)
   */
  current_price: number;
}

/**
 * API input for line items when creating new subscriptions.
 *
 * Used by create_subscription endpoint. Price is optional because
 * it can be determined from the selling plan unless overridden.
 */
export interface SubscriptionLineInputOptionalPrice {
  /**
   * Shopify product variant ID
   */
  product_variant_id: ProductVariantId;
  /**
   * Selling plan ID for subscription items
   */
  selling_plan_id?: SellingPlanId;
  /**
   * Quantity of the item
   */
  quantity?: Quantity1;
  /**
   * Custom attributes for the line item
   */
  custom_attributes?: CustomAttribute[] | null;
  /**
   * Override price (only used if allow_price_override is true)
   */
  current_price?: CurrentPrice;
}

/**
 * Holds the aggregate counts of subscriptions by status.
 */
export interface SubscriptionMetrics {
  active?: number;
  paused?: number;
  cancelled?: number;
}

/**
 * Response model for subscription queries with pagination support.
 */
export interface SubscriptionsResponse {
  subscriptions: SubscriptionContractFull[];
  /**
   * Cursor for pagination - pass this value to get the next page of results
   */
  next_cursor?: string | null;
  /**
   * The aggregated values for active, paused and cancelled subscriptions.
   */
  metrics?: SubscriptionMetrics | null;
}

/**
 * Model for token metadata.
 */
export interface TokenInfo {
  /**
   * The token name
   */
  token_name: TokenName;
  /**
   * Token status (active/revoked)
   */
  status: string;
  /**
   * When the token was created
   */
  created_at: CreatedAt1;
  /**
   * Token description
   */
  description: Description;
  /**
   * Token permissions
   */
  permissions?: string[];
  /**
   * When the token expires
   */
  expires_at?: ExpiresAt;
  /**
   * Days until expiry from creation
   */
  expires_in_days?: ExpiresInDays1;
  /**
   * Last 4 characters of the token
   */
  last4: Last4;
}

/**
 * Configuration for bulk update operations.
 */
export interface UpdateConfig {
  /**
   * Conditions for identifying the subscriptions to be changed
   */
  conditions: Conditions;
  /**
   * Message to display to the customer
   */
  update_message?: UpdateMessage | null;
  /**
   * Updates to be applied to the identified subscriptions
   */
  updates: (
    | StatusUpdateConfig
    | PriceUpdateConfig
    | VariantUpdateConfig
    | IntervalUpdateConfig
    | QuantityUpdateConfig
    | AddDiscountConfig
    | NextBillingDateUpdateConfig
    | RemoveLineConfig
  )[];
}

/**
 * Configuration for bulk update operations with name and id.
 */
export interface UpdateConfigInput {
  /**
   * Conditions for identifying the subscriptions to be changed
   */
  conditions: Conditions;
  /**
   * Message to display to the customer
   */
  update_message?: UpdateMessage | null;
  /**
   * Updates to be applied to the identified subscriptions
   */
  updates: (
    | StatusUpdateConfig
    | PriceUpdateConfig
    | VariantUpdateConfig
    | IntervalUpdateConfig
    | QuantityUpdateConfig
    | AddDiscountConfig
    | NextBillingDateUpdateConfig
    | RemoveLineConfig
  )[];
  /**
   * Identifier for the bulk update to guarantee traceability
   */
  bulk_update_id: string;
  bulk_update_name: string;
}

/**
 * Update detail with execution status.
 */
export interface UpdateDetailStatus {
  /**
   * Type of update that took place
   */
  type: string;
  /**
   * Value prior to update
   */
  old: string | number;
  /**
   * Value after update
   */
  new: string | number;
  status: "SUCCESS" | "ERROR";
}

/**
 * Message to display to customers about updates.
 */
export interface UpdateMessage {
  /**
   * Content of the message to be displayed to the customer
   */
  message: Message1;
  /**
   * If message has expiration date it will be stored here.
   */
  expiration_date?: ExpirationDate;
}

export interface ValidationError {
  loc: Loc;
  msg: Msg;
  type: Type1;
}

/**
 * Update Object for variant ID swapping.
 *
 * input:
 * variant_id: str = New variant ID.
 */
export interface VariantUpdateConfig {
  type?: "variant";
  /**
   * New variant ID
   */
  new_variant_id: NewVariantId;
}
